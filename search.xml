<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>吾辈自强，勿忘九一八！</title>
    <url>/2025/09/17/918/</url>
    <content><![CDATA[<blockquote>
<p>1931年9月18日</p>
<p>震惊中外的九一八事变爆发</p>
<p>白山黑水间，中国人民奋起反抗</p>
<p>揭开抗战14年的序幕</p>
<p>也成为世界反法西斯战争的起点</p>
<span id="more"></span>
<p>我们永远不会忘记</p>
<p>冰天雪地中孤身一人与日寇周旋</p>
<p>直至英勇牺牲的杨靖宇</p>
<p>我们永远不会忘记</p>
<p>受尽折磨也没透露组织秘密</p>
<p>最终被残忍杀害的赵一曼</p>
<p>我们永远不会忘记</p>
<p>打完最后一粒子弹</p>
<p>壮烈跳崖的狼牙山五壮士</p>
<p>……</p>
<p>这些顽强奋斗的傲骨英魂，将永载史册</p>
<p>如今，硝烟散去</p>
<p>但那些百折不挠，视死如归的抗争</p>
<p>我们从未忘记<br>
记历史，砥砺前行！</p>
<p>正义必胜！和平必胜！人民必胜！<br>
——<a href="https://ysxw.cctv.cn/article.html?toc_style_id=feeds_default&amp;t=1758125508104&amp;item_id=4457617170575898933&amp;channelId=1119&amp;fromModule=lemma_middle-info">央视新闻</a></p>
</blockquote>
<p>“九·一八事变”，又称“奉天事变”、“柳条湖事件”，是 $1931$ 年 $9$ 月 $18$ 日日本驻中国东北地区的关东军突然袭击奉天（今沈阳），以武力侵占东北的事件。</p>
<p>$1931$ 年 $9$ 月 $18$ 日晚 $10$ 时 $20$ 分，日本关东军自行炸毁南满铁路柳条湖段一段路轨，反诬中国军队破坏铁路。坐镇沈阳的关东军高级参谋板垣征四郎收到路轨被炸的报告后，当即以关东军代理司令官、先遣参谋的名义，向关东军部队发布进攻中国军队驻地北大营和沈阳的命令。各路日军向北大营发起猛烈进攻，震惊中外的“九·一八事变”爆发。$9$ 月 $19$ 日，关东军迅速占领了南满、安奉铁路沿线的重要城镇营口、田庄台、盖平（今盖州）、复县（今瓦房店）、大石桥、海城、辽阳、鞍山、铁岭、开原、昌图、四平、公主岭、安东、凤城、本溪等地。随后，又向长春等地发起进攻。用时 $4$ 个月零 $18$ 天，占领辽宁、吉林、黑龙江三省。$1932$ 年 $2$ 月，东北全境沦陷。此后，日本在东北建立伪满洲国傀儡政权，开始对东北人民长达 $14$ 年之久的奴役和殖民统治，使东北 $3000$ 多万同胞饱受亡国奴的痛苦滋味。</p>
<p>“九·一八事变”是由日本蓄意制造并发动的侵华战争，是日本帝国主义侵华的开端，标志着世界反法西斯战争的起点，揭开了第二次世界大战东方战场的序幕。“九·一八事变”爆发后，中共中央坚决主张对日抗战。在中国共产党的号召和推动下，在其他爱国党派、团体和人士的共同呼吁下，全国抗日救亡运动蓬勃兴起，东北人民和未撤走的东北军部队，组织起抗日义勇军，中国人民的局部抗战自此开始。</p>
<p>$$\Huge\text{铭记历史，勿忘国耻！}$$</p>
]]></content>
      <categories>
        <category>历史</category>
        <category>政治</category>
        <category>新闻</category>
      </categories>
      <tags>
        <tag>历史</tag>
        <tag>政治</tag>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/12/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>二分图</title>
    <url>/2024/12/31/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<h1>二分图</h1>
<p>若一张无向图 $G$，可以将所有的点分成 $2$ 个点集，且 $2$ 个点集内部没有连边，那么称 $G$ 可以划分为一张二分图。</p>
<ul>
<li>注意：二分图的划分不一定唯一，且不一定连通。有向图在实际问题中，也可以划分一分图</li>
</ul>
<h2 id="二分图存在的充要条件">二分图存在的充要条件</h2>
<ul>
<li>没有奇环</li>
</ul>
<h2 id="二分图的判定">二分图的判定</h2>
<p>染色法，任意选择没有访问的点开始 dfs，并且 $0,1$ 交替染色，只要出现一条边的 $2$ 个端点颜色相同，那么就不是二分图。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color[x] = c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (color[nxt] == c)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!color[nxt])</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">dfs</span>(nxt, <span class="number">3</span> - c))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图最大匹配">二分图最大匹配</h2>
<p>对于一张无向图 $G$，且 $G$ 可以划分为二分图，我们将 $1$ 条边称为 $1$ 组“匹配”，在 $G$ 中选出最多的匹配且所有选出的边不共点，那么这一组边集，就是一组 $G$ 的最大匹配。</p>
<h3 id="匈牙利算法">匈牙利算法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hungary</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (!vis[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			vis[nxt] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (!match[nxt] || <span class="built_in">hungary</span>(match[nxt]))</span><br><span class="line">			&#123;</span><br><span class="line">				match[nxt] = x;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图最小点覆盖">二分图最小点覆盖</h2>
<p>对于一张二分图 $G$，选取最小的点集 $S$，使得点集内的点能覆盖所有的边。（在任意一条边至少有 $1$ 个端点在 $S$ 中）</p>
<p>性质：</p>
<ul>
<li>二分图最大匹配=二分图最小点覆盖</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp</title>
    <url>/2024/12/31/%E5%8C%BA%E9%97%B4dp/</url>
    <content><![CDATA[<h1>区间DP</h1>
<ul>
<li>是一类子问题从短到长，而不是从左到右的动态规划问题。</li>
</ul>
<h2 id="状态">状态</h2>
<p>一般是：$dp_{i,j}$ 表示将区间 $[i,j]$ 的元素合并、拆分的最值、方案数。</p>
<h2 id="转移">转移</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)<span class="comment">//这问题</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)<span class="comment">//状态</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)<span class="comment">//决策点</span></span><br><span class="line">		dp[i][j] = 运算(dp[i][j], 状态转移方程);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="例题">例题</h2>
<h3 id="洛谷P1775">洛谷P1775</h3>
<p><a href="https://www.luogu.com.cn/problem/P1775">P1775 石子合并（弱化版）</a></p>
<blockquote>
<p>设有 $N(N \le 300)$ 堆石子排成一排，其编号为 $1,2,3,\cdots,N$。每堆石子有一定的质量 $m_i\ (m_i \le 1000)$。现在要将这 $N$ 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻。合并时由于选择的顺序不同，合并的总代价也不相同。试找出一种合理的方法，使总的代价最小，并输出最小代价。</p>
</blockquote>
<h4 id="状态-2">状态</h4>
<p>$dp_{i,j}$ 表示将区间 $[i,j]$ 的元素合并的最小代价。</p>
<h4 id="转移-2">转移</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">	dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">dp[i][j] += sum[j] - sum[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="答案">答案</h4>
<p>$dp_{1,n}$</p>
<h3 id="洛谷P3146">洛谷P3146</h3>
<p><a href="https://www.luogu.com.cn/problem/P3146">P3146 [USACO16OPEN] 248 G</a></p>
<blockquote>
<p>贝西喜欢在手机上下载游戏来玩，尽管她确实觉得对于自己巨大的蹄子来说，小小的触摸屏用起来相当笨拙。</p>
<p>她对当前正在玩的这个游戏特别感兴趣。游戏开始时给定一个包含 $N$ 个正整数的序列（$2 \leq N \leq 248$），每个数的范围在 $1 \ldots 40$ 之间。在一次操作中，贝西可以选择两个相邻且相等的数，将它们替换为一个比原数大 1 的数（例如，她可以将两个相邻的 7 替换为一个 8）。游戏的目标是最大化最终序列中的最大数值。请帮助贝西获得尽可能高的分数！</p>
</blockquote>
<h4 id="状态-3">状态</h4>
<p>$dp_{i,j}$ 表示将区间 $[i,j]$ 的元素合并的最大能得到的数。</p>
<h4 id="转移-3">转移</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">	<span class="keyword">if</span> (dp[i][k] == dp[k + <span class="number">1</span>][j])</span><br><span class="line">		dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="答案-2">答案</h4>
<p>$max(dp_{i,j})$</p>
<h3 id="洛谷P1622">洛谷P1622</h3>
<p><a href="https://www.luogu.com.cn/problem/P1622">P1622 释放囚犯</a></p>
<blockquote>
<p>Caima 王国中有一个奇怪的监狱，这个监狱一共有 $P$ 个牢房，这些牢房一字排开，第 $i$ 个紧挨着第 $i+1$ 个（最后一个除外）。现在正好牢房是满的。</p>
<p>上级下发了一个释放名单，要求每天释放名单上的一个人。这可把看守们吓得不轻，因为看守们知道，现在牢房中的 $P$ 个人，可以相互之间传话。如果某个人离开了，那么原来和这个人能说上话的人，都会很气愤，导致他们那天会一直大吼大叫，搞得看守很头疼。如果给这些要发火的人吃上肉，他们就会安静点。</p>
</blockquote>
<h4 id="状态-4">状态</h4>
<p>$dp_{i,j}$ 表示将区间 $[a_i,a_j]$ 的人放在一起需要给的肉的数量。</p>
<h4 id="转移-4">转移</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">	dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">dp[i][j] += sum[j] - sum[i - <span class="number">1</span>] + j - i - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="答案-3">答案</h4>
<p>$dp_{1,n}$</p>
<h3 id="洛谷P2890">洛谷P2890</h3>
<p><a href="https://www.luogu.com.cn/problem/P2890">P2890 [USACO07OPEN] Cheapest Palindrome G</a></p>
<blockquote>
<p>给定一个由 $n$ 个不同的小写字母构成的长 $m$ 的字符串 $s$。可以通过<strong>在 $s$ 的任意位置</strong>增减字母将 $s$ 改为回文串。增减字母的花费不同，求最小花费。</p>
</blockquote>
<h4 id="状态-5">状态</h4>
<p>$dp_{i,j}$ 表示将区间 $[i,j]$ 变成回文串的最小花费。</p>
<h4 id="转移-5">转移</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">	dp[i][j] = (len &gt; <span class="number">2</span> ? dp[i + <span class="number">1</span>][j - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">dp[i][j] = <span class="built_in">min</span>(&#123; dp[i][j],dp[i][j - <span class="number">1</span>] + a[s[j]],dp[i + <span class="number">1</span>][j] + a[s[i]] &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="答案-4">答案</h4>
<p>$dp_{1,n}$</p>
<h4 id="类似题">类似题</h4>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1435">P1435 [IOI 2000] 回文字串</a>，只不过代价为 $1$。</li>
</ul>
<h3 id="洛谷P2858">洛谷P2858</h3>
<p><a href="https://www.luogu.com.cn/problem/P2858">P2858 [USACO06FEB] Treats for the Cows G/S</a></p>
<blockquote>
<p>约翰经常给产奶量高的奶牛发特殊津贴，于是很快奶牛们拥有了大笔不知该怎么花的钱。为此，约翰购置了 $N$（$1 \leq N \leq 2000$） 份美味的零食来卖给奶牛们。每天约翰售出一份零食。当然约翰希望这些零食全部售出后能得到最大的收益，这些零食有以下这些有趣的特性：</p>
<ul>
<li>零食按照 $1, \ldots, N$ 编号，它们被排成一列放在一个很长的盒子里。盒子的两端都有开口，约翰每天可以从盒子的任一端取出最外面的一个。</li>
<li>与美酒与好吃的奶酪相似，这些零食储存得越久就越好吃。当然，这样约翰就可以把它们卖出更高的价钱。</li>
<li>每份零食的初始价值不一定相同。约翰进货时，第i份零食的初始价值为 $V_i$（$1 \leq V \leq 1000$）。</li>
<li>第i份零食如果在被买进后的第 $a$ 天出售，则它的售价是 $V_i \times a$。</li>
</ul>
<p>$V_i$ 的是从盒子顶端往下的第i份零食的初始价值。约翰告诉了你所有零食的初始价值，并希望你能帮他计算一下，在这些零食全被卖出后，他最多能得到多少钱。</p>
</blockquote>
<h4 id="状态-6">状态</h4>
<p>$dp_{i,j}$ 表示只将区间 $[a_i,a_j]$ 买完的最大价值。</p>
<h4 id="转移-6">转移</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + sum[j] - sum[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="答案-5">答案</h4>
<p>$dp_{1,n}$</p>
<h3 id="洛谷P4170">洛谷P4170</h3>
<p><a href="https://www.luogu.com.cn/problem/P4170">P4170 [CQOI2007] 涂色</a></p>
<h4 id="状态-7">状态</h4>
<p>$dp_{i,j}$ 表示将区间 $[i,j]$ 达到目标的最少涂色次数。</p>
<h4 id="转移-7">转移</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">	dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">		dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j]);</span><br></pre></td></tr></table></figure>
<h4 id="答案-6">答案</h4>
<p>$dp_{1,n}$</p>
<h3 id="洛谷P3205">洛谷P3205</h3>
<p><a href="https://www.luogu.com.cn/problem/P3205">P3205 [HNOI2010] 合唱队</a></p>
<blockquote>
<p>…<br>
小 A 心中有一个理想队形，他想知道多少种初始队形可以获得理想的队形。<br>
请求出答案对 $19650827$ 取模的值。</p>
</blockquote>
<h4 id="状态-8">状态</h4>
<p>$dp_{i,j,0/1}$ 表示这一次是添加到开头/结尾，将区间 $[i,j]$ 达到理想的队形的方案数。</p>
<h4 id="转移-8">转移</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i] &lt; a[i + <span class="number">1</span>])</span><br><span class="line">	dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i + <span class="number">1</span>][j][<span class="number">0</span>]) % mod;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; a[j])</span><br><span class="line">	dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i + <span class="number">1</span>][j][<span class="number">1</span>]) % mod;</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j - <span class="number">1</span>])</span><br><span class="line">	dp[i][j][<span class="number">1</span>] = (dp[i][j][<span class="number">1</span>] + dp[i][j - <span class="number">1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[i])</span><br><span class="line">	dp[i][j][<span class="number">1</span>] = (dp[i][j][<span class="number">1</span>] + dp[i][j - <span class="number">1</span>][<span class="number">0</span>]) % mod;</span><br></pre></td></tr></table></figure>
<h4 id="答案-7">答案</h4>
<p>$(dp_{1,n,0}+dp_{1,n,1})\mod 19650827$</p>
<h2 id="总结">总结</h2>
<ol>
<li>题目特征上有合并类、拆分类、两端处理类；</li>
<li>求最值类区间DP，需要注意无效状态初始化；</li>
<li>输出答案前，判断是否需要枚举；</li>
<li>决策点一般是在中间枚举或是两个端点；</li>
<li>若转移时可以从 $dp_{i+1,j-1}$ 递推，需要注意 $len=2$ 的情况；</li>
<li>初始状态要分析清楚。</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>动态规划</category>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp（三）</title>
    <url>/2024/12/31/%E5%8C%BA%E9%97%B4dp%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1>区间dp（三）</h1>
<h2 id="洛谷P1880">洛谷P1880</h2>
<p><a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995] 石子合并 - 洛谷</a></p>
<p>石子在圆形操场的四周摆放，直接当没有环形区间dp显然会少答案。那么我们一定要这么做怎么办？少了的话可以加回来，斩环为链，数组多一倍，再区间dp。</p>
<p>$dp_{0/1,i,j}$ 表示区间合并 $[i,j]$ 的最小/最大值。</p>
<p>答案为 $\displaystyle\min_{1\le i\lt n}^idp_{0,i,i+n-1}$ 和 $\displaystyle\max_{1\le i\lt n}^idp_{1,i,i+n-1}$。</p>
<p>$\displaystyle dp_{0,i,j}=\min_{i\le k\lt j}^k\left(dp_{0,i,k}+dp_{0,k+1,j}+\sum_{i\le l\le j}^la_l\right)$，$\displaystyle dp_{1,i,j}=\max_{i\le k\lt j}^k\left(dp_{1,i,k}+dp_{1,k+1,j}+\sum_{i\le l\le j}^la_l\right)$。</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], dp[<span class="number">2</span>][N][N], sum[N], maxi, mini = LLONG_MAX;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">memset</span>(dp[<span class="number">1</span>], <span class="number">0xcf</span>, <span class="keyword">sizeof</span> dp[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		a[i + n] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + a[i], dp[<span class="number">0</span>][i][i] = dp[<span class="number">1</span>][i][i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i + len - <span class="number">1</span>, tmp = sum[j] - sum[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[<span class="number">0</span>][i][j] = <span class="built_in">min</span>(dp[<span class="number">0</span>][i][j], dp[<span class="number">0</span>][i][k] + dp[<span class="number">0</span>][k + <span class="number">1</span>][j] + tmp);</span><br><span class="line">				dp[<span class="number">1</span>][i][j] = <span class="built_in">max</span>(dp[<span class="number">1</span>][i][j], dp[<span class="number">1</span>][i][k] + dp[<span class="number">1</span>][k + <span class="number">1</span>][j] + tmp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mini = <span class="built_in">min</span>(mini, dp[<span class="number">0</span>][i][i + n - <span class="number">1</span>]);</span><br><span class="line">		maxi = <span class="built_in">max</span>(maxi, dp[<span class="number">1</span>][i][i + n - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; mini &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; maxi;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P1063">洛谷P1063</h2>
<p><a href="https://www.luogu.com.cn/problem/P1063">P1063 能量项链</a></p>
<p>这一题也是斩环为链，但需要注意计算答案时要弄清楚位置。</p>
<p>$dp_{i,j}$ 表示区间 $[i,j]$ 的最大能量值。</p>
<p>$\displaystyle dp_{i,j}=\max_{i\lt k\lt j}^k\left(dp_{i,k}+dp_{k,j}+a_i\cdot a_j\cdot a_k\right)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], dp[N][N], maxi;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		a[i + n] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n + <span class="number">1</span>; len++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + dp[k][j] +</span><br><span class="line">					a[i] * a[j] * a[k]);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		maxi = <span class="built_in">max</span>(maxi, dp[i][i + n]); <span class="comment">//这道题不要减1,因为头尾标记共用</span></span><br><span class="line">	cout &lt;&lt; maxi;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P4342">洛谷P4342</h2>
<p><a href="https://www.luogu.com.cn/problem/P4342">P4342 [IOI 1998] Polygon</a></p>
<p>这道题不仅需要计算最大值，因为有乘法操作，所以需要维护最小值。</p>
<p>$dp_{i,j,0/1}$ 表示计算区间 $[i,j]$ 的最小值/最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], dp[N][N][<span class="number">2</span>], ans = INT_MIN;</span><br><span class="line"><span class="type">char</span> c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> x + y;</span><br><span class="line">	<span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">help</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">bool</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!f)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(x, y);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; c[i] &gt;&gt; a[i];</span><br><span class="line">		c[n + i] = c[i];</span><br><span class="line">		a[n + i] = a[i];</span><br><span class="line">		dp[i][i][<span class="number">0</span>] = dp[i][i][<span class="number">1</span>] = dp[n + i][n + i][<span class="number">0</span>] = dp[n + i][n + i][<span class="number">1</span>] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	c[<span class="number">2</span> * n + <span class="number">1</span>] = c[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">			dp[i][j][<span class="number">0</span>] = INT_MAX; <span class="comment">//最小值和最大值初始状态不要赋错</span></span><br><span class="line">			dp[i][j][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">8</span>; l++)</span><br><span class="line">					dp[i][j][l &amp; <span class="number">1</span>] = <span class="built_in">help</span>(dp[i][j][l &amp; <span class="number">1</span>],</span><br><span class="line">						<span class="built_in">work</span>(dp[i][k][(l &amp; <span class="number">2</span>) &gt;&gt; <span class="number">1</span>], dp[k + <span class="number">1</span>][j][(l &amp; <span class="number">4</span>) &gt;&gt; <span class="number">2</span>],</span><br><span class="line">							c[k + <span class="number">1</span>]), l &amp; <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, dp[i][n + i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (dp[i][n + i - <span class="number">1</span>][<span class="number">1</span>] == ans)</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P6064">洛谷P6064</h2>
<p><a href="https://www.luogu.com.cn/problem/P6064">P6064 [USACO05JAN] Naptime G</a></p>
<p>我们发现第 $1$ 时间端依赖前一天的最后的时间段，所以这道题需要分情况讨论前一天的最后的时间段是否睡觉，且不是区间dp。</p>
<p>$dp_{i,j,0/1}$ 表示枚举到第 $i$ 端时间，睡了 $j$ 小时，第 $i$ 小时是否睡觉的最大效用值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3830</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], dp[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">bool</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = f * a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(&#123; dp[i][j][<span class="number">0</span>],dp[i - <span class="number">1</span>][j][<span class="number">0</span>],dp[i - <span class="number">1</span>][j][<span class="number">1</span>] &#125;);</span><br><span class="line">			<span class="keyword">if</span> (j)</span><br><span class="line">				dp[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(&#123; dp[i][j][<span class="number">1</span>],dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>],</span><br><span class="line">					dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + a[i] &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n][m][f];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(<span class="built_in">work</span>(<span class="literal">false</span>), <span class="built_in">work</span>(<span class="literal">true</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>动态规划</category>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp（二）</title>
    <url>/2024/12/31/%E5%8C%BA%E9%97%B4dp%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1>区间dp（二）</h1>
<h2 id="洛谷P1220">洛谷P1220</h2>
<p><a href="https://www.luogu.com.cn/problem/P1220">P1220 关路灯</a></p>
<blockquote>
<p>请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。</p>
</blockquote>
<p>老张关路灯像区间dp，可以发现他关路灯时不会关关过的中间加的，不然不优。</p>
<h3 id="状态">状态</h3>
<p>$dp_{i,j,0/1}$ 表示区间关 $[i,j]$ 最后达到 $i/j$ 的最少功耗。</p>
<h3 id="答案">答案</h3>
<p>$$\min(dp_{1,n,0},dp_{1,n,1})$$</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dp[N][N][<span class="number">2</span>], a[N], b[N], sum[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i] &gt;&gt; b[i], sum[i] = sum[i - <span class="number">1</span>] + b[i];</span><br><span class="line">	dp[m][m][<span class="number">0</span>] = dp[m][m][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i + len - <span class="number">1</span>, tmp = sum[n] - sum[j] + sum[i],</span><br><span class="line">				tmp1 = sum[n] - sum[j - <span class="number">1</span>] + sum[i - <span class="number">1</span>];</span><br><span class="line">			dp[i][j][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j][<span class="number">0</span>] + (a[i + <span class="number">1</span>] - a[i]) * tmp,</span><br><span class="line">				dp[i + <span class="number">1</span>][j][<span class="number">1</span>] + (a[j] - a[i]) * tmp);</span><br><span class="line">			dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>][<span class="number">0</span>] + (a[j] - a[i]) * tmp1,</span><br><span class="line">				dp[i][j - <span class="number">1</span>][<span class="number">1</span>] + (a[j] - a[j - <span class="number">1</span>]) * tmp1);</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">min</span>(dp[<span class="number">1</span>][n][<span class="number">0</span>], dp[<span class="number">1</span>][n][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P8675">洛谷P8675</h2>
<p><a href="https://www.luogu.com.cn/problem/P8675">P8675 [蓝桥杯 2018 国 B] 搭积木</a></p>
<h3 id="状态-2">状态</h3>
<p>$dp_{l,i,j}$ 表示搭 $l$ 层的区间 $[i,j]$ 的方案数。</p>
<h3 id="答案-2">答案</h3>
<p>$$\displaystyle\left(\sum^l_{1\le l\le n}\sum^i_{1\le i\le m}\sum^j_{i\le j\le m}dp_{l,i,j}\right)\bmod{10^9+7}$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dp[N][N][N], sum[N][N], vis[N][N], ans, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> c;</span><br><span class="line">			cin &gt;&gt; c;</span><br><span class="line">			vis[i][j] = vis[i][j - <span class="number">1</span>] + (c == <span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= m; j++)</span><br><span class="line">				sum[i][j] = (sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] +</span><br><span class="line">					dp[l - <span class="number">1</span>][i][j] + mod) % mod;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= m; len++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= m; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (!(vis[l][j] - vis[l][i - <span class="number">1</span>]))</span><br><span class="line">					ans = (ans + (dp[l][i][j] = (sum[i][m] - sum[i][j - <span class="number">1</span>] +</span><br><span class="line">						mod) % mod)) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (ans + <span class="number">1</span>) % mod;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P4302">洛谷P4302</h2>
<p><a href="https://www.luogu.com.cn/problem/P4302">P4302 [SCOI2003] 字符串折叠</a></p>
<blockquote>
<p>给一个字符串，求它的最短折叠。</p>
<p>例如 <code>AAAAAAAAAABABABCCD</code> 的最短折叠为：<code>9(A)3(AB)CCD</code>。</p>
<p><code>NEERCYESYESYESNEERCYESYESYES</code> 的是 <code>2(NEERC3(YES))</code></p>
</blockquote>
<h3 id="状态-3">状态</h3>
<p>$dp_{i,j}$ 表示折叠区间 $[i,j]$ 的最短长度。</p>
<h3 id="答案-3">答案</h3>
<p>$$dp_{1,n}$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, dp[N][N];</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= y; i++)</span><br><span class="line">		<span class="keyword">if</span> (s[i] != s[x + ((i - x) % z)])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	n = s.<span class="built_in">size</span>();</span><br><span class="line">	s = <span class="string">&#x27;#&#x27;</span> + s;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		dp[i][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">			dp[i][j] = len;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">				<span class="keyword">if</span> (!(len % (k - i + <span class="number">1</span>)) &amp;&amp; <span class="built_in">check</span>(i, j, k - i + <span class="number">1</span>))</span><br><span class="line">					dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + <span class="number">2</span> +</span><br><span class="line">						(<span class="type">int</span>)<span class="built_in">to_string</span>(len / (k - i + <span class="number">1</span>)).<span class="built_in">size</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; dp[<span class="number">1</span>][n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P2135">洛谷P2135</h2>
<p><a href="https://www.luogu.com.cn/problem/P2135">P2135 方块消除</a></p>
<p>双倍经验：<a href="https://www.luogu.com.cn/problem/UVA10559">UVA10559 方块消除 Blocks</a></p>
<blockquote>
<p>Jimmy 最近迷上了一款叫做方块消除的游戏。游戏规则如下：$n$ 个带颜色方格排成一列，相同颜色的方块连成一个区域（如果两个相邻方块颜色相同，则这两个方块属于同一区域）。为简化题目，将连起来的同一颜色方块的数目用一个数表示。</p>
<p>例如，<code>9 122233331</code> 表示为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 1</span><br><span class="line">1 3 4 1</span><br></pre></td></tr></table></figure>
<p>游戏时，你可以任选一个区域消去。设这个区域包含的方块数为 $x$，则将得到 $x^2$ 个分值。方块消去之后，其余的方块就会竖直落到底部或其他方块上。而且当有一列方块被完全消去时，其右边的所有方块就会向左移一格。Jimmy 希望你能找出得最高分的最佳方案，你能帮助他吗？</p>
</blockquote>
<h3 id="状态-4">状态</h3>
<p>$dp_{i,j,k}$ 表示消去区间 $[i,j]$ 且一起消去了 $i$ 前面和它相同的 $k$ 个的最高可能得分。</p>
<h3 id="答案-4">答案</h3>
<p>$$dp_{1,n,0}$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*此代码状态设计相反*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], b[N], dp[N][N][<span class="number">1005</span>], sum[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (a[i] == a[j])</span><br><span class="line">				sum[i] += b[j];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= sum[i]; j++)</span><br><span class="line">			dp[i][i][j] = (b[i] + j) * (b[i] + j);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= sum[j]; k++)</span><br><span class="line">				dp[i][j][k] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>] + (b[j] + k) * (b[j] + k);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j - <span class="number">2</span>; k++)</span><br><span class="line">				<span class="keyword">if</span> (a[j] == a[k])</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt;= sum[j]; l++)</span><br><span class="line">						dp[i][j][l] = <span class="built_in">max</span>(dp[i][j][l], dp[i][k][b[j] + l] +</span><br><span class="line">							dp[k + <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; dp[<span class="number">1</span>][n][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], b[N], dp[N][N][<span class="number">1005</span>], sum[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">			<span class="keyword">if</span> (a[i] == a[j])</span><br><span class="line">				sum[i] += b[j];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= sum[i]; j++)</span><br><span class="line">			dp[i][i][j] = (b[i] + j) * (b[i] + j);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= sum[i]; k++)</span><br><span class="line">				dp[i][j][k] = dp[i + <span class="number">1</span>][j][<span class="number">0</span>] + (b[i] + k) * (b[i] + k);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">				<span class="keyword">if</span> (a[i] == a[k + <span class="number">1</span>])</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt;= sum[i]; l++)</span><br><span class="line">						dp[i][j][l] = <span class="built_in">max</span>(dp[i][j][l], dp[i + <span class="number">1</span>][k][<span class="number">0</span>] +</span><br><span class="line">							dp[k + <span class="number">1</span>][j][b[i] + l]);</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; dp[<span class="number">1</span>][n][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>动态规划</category>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡树</title>
    <url>/2019/12/31/%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<h1>平衡树</h1>
<p>全称是二叉搜索平衡树</p>
<p>二叉搜索树：对于一棵二叉树，每个节点有权值 $val$，任意节点 $x$ 的左子树的权值小于等于 $val_x$，右子树反之。</p>
<p>二叉搜索树的优点：</p>
<ol>
<li>具有单调性，可以 $log_2$ 的时间查找。</li>
<li>二叉搜索树的中序遍历是单调不减的，可以将下标当做权值，这样一个序列可以映射到一棵二叉搜索树。</li>
</ol>
<p>为什么需要平衡树？</p>
<ul>
<li>一个序列对应的二叉搜索树不唯一。我们希望找到高度最小的那颗应用。</li>
</ul>
<p>若一棵二叉树的任意一个结点 $x$，其左右子树高度差不超过 $1$，称为二叉平衡树。</p>
<span id="more"></span>
<p>算法竞赛领域常用的平衡树：</p>
<ol>
<li>treap</li>
<li>splay</li>
<li>fhq_treap</li>
</ol>
<p>其中，treap 和 fhq_treap 利用的是随机平衡，不追求绝对平衡。splay 是贪心策略平衡。treap 和 splay 都是通过旋转改变形态，fhq_treap 通过分裂和合并来改变形态。</p>
<h2 id="Fhq-treap-实现">Fhq_treap 实现</h2>
<ol>
<li>
<p>分裂操作</p>
<p>将一棵平衡树分裂成 $a$ 和 $b$ 两棵子树，且 $val_a\le val,val_b&gt;val$。$val$ 是选取的某个数。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val, l, r, size, rnk;</span><br><span class="line">&#125;tree[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[cur].size = tree[tree[cur].l].size + tree[tree[cur].r].size + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!cur)</span><br><span class="line">	&#123;</span><br><span class="line">		a = b = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tree[cur].val &lt;= val)</span><br><span class="line">	&#123;</span><br><span class="line">		a = cur;</span><br><span class="line">		<span class="built_in">split</span>(tree[cur].r, tree[cur].r, b, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		b = cur;</span><br><span class="line">		<span class="built_in">split</span>(tree[cur].l, a, tree[cur].l, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">update</span>(cur);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>合并操作</p>
<p>将 $a,b$ 两棵平衡树合并，且 $a$ 平衡树的任意权值一定小于等于 $b$ 平衡树的任意权值。</p>
</li>
</ol>
<p>模板完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, root, cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val, l, r, size, rnk;</span><br><span class="line">&#125;tree[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[cur].size = tree[tree[cur].l].size + tree[tree[cur].r].size + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_node</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[++cnt] = &#123; val,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="built_in">rand</span>() &#125;;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!cur)</span><br><span class="line">	&#123;</span><br><span class="line">		a = b = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tree[cur].val &lt;= val)</span><br><span class="line">	&#123;</span><br><span class="line">		a = cur;</span><br><span class="line">		<span class="built_in">split</span>(tree[cur].r, tree[cur].r, b, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		b = cur;</span><br><span class="line">		<span class="built_in">split</span>(tree[cur].l, a, tree[cur].l, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">update</span>(cur);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>&amp; cur, <span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!a || !b)</span><br><span class="line">	&#123;</span><br><span class="line">		cur = a + b;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tree[a].rnk &lt;= tree[b].rnk)</span><br><span class="line">	&#123;</span><br><span class="line">		cur = a;</span><br><span class="line">		<span class="built_in">merge</span>(tree[a].r, tree[a].r, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cur = b;</span><br><span class="line">		<span class="built_in">merge</span>(tree[b].l, a, tree[b].l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">update</span>(cur);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>&amp; cur, <span class="type">int</span> val)</span><span class="comment">//插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="built_in">add_node</span>(val);</span><br><span class="line">	<span class="built_in">split</span>(cur, a, b, val);</span><br><span class="line">	<span class="built_in">merge</span>(a, a, c);</span><br><span class="line">	<span class="built_in">merge</span>(cur, a, b);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span>&amp; cur, <span class="type">int</span> val)</span><span class="comment">//输出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">split</span>(cur, a, b, val);</span><br><span class="line">	<span class="built_in">split</span>(a, a, c, val - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">merge</span>(c, tree[c].l, tree[c].r);</span><br><span class="line">	<span class="built_in">merge</span>(a, a, c);</span><br><span class="line">	<span class="built_in">merge</span>(cur, a, b);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_num</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> x)</span><span class="comment">//寻找第 $x$ 个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (tree[tree[cur].l].size + <span class="number">1</span> != x)</span><br><span class="line">		<span class="keyword">if</span> (tree[tree[cur].l].size &gt;= x)</span><br><span class="line">			cur = tree[cur].l;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			x -= tree[tree[cur].l].size + <span class="number">1</span>;</span><br><span class="line">			cur = tree[cur].r;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> tree[cur].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_rank</span><span class="params">(<span class="type">int</span>&amp; cur, <span class="type">int</span> val)</span><span class="comment">//寻找 $val$ 的第一个位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">split</span>(cur, a, b, val - <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> tmp = tree[a].size + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">merge</span>(cur, a, b);</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prev</span><span class="params">(<span class="type">int</span>&amp; cur, <span class="type">int</span> val)</span><span class="comment">//寻找前驱</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">split</span>(cur, a, b, val - <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> tmp = <span class="built_in">find_num</span>(a, tree[a].size);</span><br><span class="line">	<span class="built_in">merge</span>(cur, a, b);</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">suf</span><span class="params">(<span class="type">int</span>&amp; cur, <span class="type">int</span> val)</span><span class="comment">//寻找后继</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">split</span>(cur, a, b, val);</span><br><span class="line">	<span class="type">int</span> tmp = <span class="built_in">find_num</span>(b, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">merge</span>(cur, a, b);</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> opt, val;</span><br><span class="line">		cin &gt;&gt; opt &gt;&gt; val;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">insert</span>(root, val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">			<span class="built_in">del</span>(root, val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>)</span><br><span class="line">			cout &lt;&lt; <span class="built_in">find_rank</span>(root, val) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">4</span>)</span><br><span class="line">			cout &lt;&lt; <span class="built_in">find_num</span>(root, val) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">5</span>)</span><br><span class="line">			cout &lt;&lt; <span class="built_in">prev</span>(root, val) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; <span class="built_in">suf</span>(root, val) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题">例题</h3>
<h4 id="洛谷P1486">洛谷P1486</h4>
<p><a href="https://www.luogu.com.cn/problem/P1486">P1486 郁闷的出纳员</a></p>
<p>NOI2004 的题。</p>
<blockquote>
<p>第一行有两个整数 $n$ 和 $\min$。$n$ 表示下面有多少条命令，$\min$ 表示工资下界。</p>
<p>接下来的 $n$ 行，每行一个字符 $x$ 和一个整数 $k$，表示一条命令。命令可以是以下四种之一：</p>
<ul>
<li><code>I k</code>  新建一个工资档案，初始工资为 $k$。如果某员工的初始工资低于工资下界，他将立刻离开公司。</li>
<li><code>A k</code>   把每位员工的工资加上 $k$。</li>
<li><code>S k</code>   把每位员工的工资扣除 $k$。</li>
<li><code>F k</code>    查询第 $k$ 多的工资。</li>
</ul>
<p>在初始时，可以认为公司里一个员工也没有。</p>
</blockquote>
<p>维护一个全局懒标记，懒标记减的时候删除离开的人。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> c;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; c &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">			<span class="keyword">if</span> (x &gt;= m)</span><br><span class="line">				<span class="built_in">insert</span>(root, x - tag);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">			tag += x;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tag -= x;</span><br><span class="line">			<span class="keyword">while</span> (root &amp;&amp; <span class="built_in">find_num</span>(root, <span class="number">1</span>) + tag &lt; m)</span><br><span class="line">				<span class="built_in">del</span>(root, <span class="built_in">find_num</span>(root, <span class="number">1</span>)), sum++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span> (!root || tree[root].size &lt; x)</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout &lt;&lt; <span class="built_in">find_num</span>(root, tree[root].size - x + <span class="number">1</span>) + tag &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="洛谷P2234">洛谷P2234</h4>
<p><a href="https://www.luogu.com.cn/problem/P2234">P2234 营业额统计</a></p>
<blockquote>
<p>而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。</p>
<p>我们定义，一天的最小波动值 = $\min{|\text{该天以前某一天的营业额}-\text{该天营业额}|}$。</p>
<p>特别地，第一天的最小波动值为第一天的营业额。</p>
</blockquote>
<p>和前驱后继减，即可保证最小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="built_in">insert</span>(root, x);</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">			sum += x;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tree[root].size == <span class="built_in">find_rank</span>(root, x))</span><br><span class="line">			sum += <span class="built_in">abs</span>(<span class="built_in">prev</span>(root, x) - x);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">find_rank</span>(root, x) == <span class="number">1</span>)</span><br><span class="line">			sum += <span class="built_in">abs</span>(<span class="built_in">suf</span>(root, x) - x);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			sum += <span class="built_in">min</span>(<span class="built_in">abs</span>(<span class="built_in">prev</span>(root, x) - x), <span class="built_in">abs</span>(<span class="built_in">suf</span>(root, x) - x));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="洛谷P3224">洛谷P3224</h4>
<p><a href="https://www.luogu.com.cn/problem/P3224">P3224 永无乡</a></p>
<blockquote>
<p>永无乡包含 $n$ 座岛，编号从 $1$ 到 $n$ ，每座岛都有自己的独一无二的重要度，按照重要度可以将这 $n$ 座岛排名，名次用 $1$  到 $n$ 来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛到达另一个岛。如果从岛 $a$ 出发经过若干座（含 $0$ 座）桥可以 到达岛 $b$ ，则称岛 $a$ 和岛 $b$ 是连通的。</p>
<p>现在有两种操作：</p>
<p><code>B x y</code> 表示在岛 $x$ 与岛 $y$ 之间修建一座新桥。</p>
<p><code>Q x k</code> 表示询问当前与岛 $x$ 连通的所有岛中第 $k$ 重要的是哪座岛，即所有与岛 $x$ 连通的岛中重要度排名第 $k$ 小的岛是哪座，请你输出那个岛的编号。</p>
</blockquote>
<p>使用并查集+平衡树，合并使用启发式合并，即拆小的往大的上 merge。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == fa[x])</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = x, val = tree[x].val;</span><br><span class="line">	<span class="type">int</span> l = tree[x].l, r = tree[x].r;</span><br><span class="line">	tree[x].l = tree[x].r = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">split</span>(y, a, b, val);</span><br><span class="line">	<span class="built_in">merge</span>(a, a, c);</span><br><span class="line">	<span class="built_in">merge</span>(y, a, b);</span><br><span class="line">	<span class="built_in">dfs</span>(l, y);</span><br><span class="line">	<span class="built_in">dfs</span>(r, y);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionn</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x);</span><br><span class="line">	y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x != y)</span><br><span class="line">		<span class="keyword">if</span> (tree[root[x]].size &lt;= tree[root[y]].size)</span><br><span class="line">		&#123;</span><br><span class="line">			fa[x] = y;</span><br><span class="line">			<span class="built_in">dfs</span>(root[x], root[y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(x, y);</span><br><span class="line">			fa[x] = y;</span><br><span class="line">			<span class="built_in">dfs</span>(root[x], root[y]);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i], b[a[i]] = i, fa[i] = i, root[i] = i,</span><br><span class="line">		tree[i] = &#123; a[i],<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="built_in">rand</span>() &#125;;</span><br><span class="line">	cnt = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="built_in">unionn</span>(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span> (q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> c;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; c &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">			<span class="built_in">unionn</span>(x, y);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span> (tree[root[<span class="built_in">find</span>(x)]].size &lt; y)</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout &lt;&lt; b[<span class="built_in">find_num</span>(root[<span class="built_in">find</span>(x)], y)] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="洛谷P6136">洛谷P6136</h4>
<p><a href="https://www.luogu.com.cn/problem/P6136">P6136 【模板】普通平衡树（数据加强版）</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="built_in">insert</span>(root, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> opt, val;</span><br><span class="line">		cin &gt;&gt; opt &gt;&gt; val;</span><br><span class="line">		val ^= last;</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">insert</span>(root, val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)</span><br><span class="line">			<span class="built_in">del</span>(root, val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>)</span><br><span class="line">			ans ^= (last = <span class="built_in">find_rank</span>(root, val));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">4</span>)</span><br><span class="line">			ans ^= (last = <span class="built_in">find_num</span>(root, val));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">5</span>)</span><br><span class="line">			ans ^= (last = <span class="built_in">prev</span>(root, val));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ans ^= (last = <span class="built_in">suf</span>(root, val));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文艺平衡树（fhq-treap-版）">文艺平衡树（fhq_treap 版）</h2>
<p>需要区间反转时，为了实现区间翻转，我们使用懒标记（lazy tag），像线段树一样。</p>
<ul>
<li>
<p>pushdown 函数</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tree[cur].tag)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">swap</span>(tree[cur].l, tree[cur].r);</span><br><span class="line">	tree[tree[cur].l].tag ^= <span class="number">1</span>;</span><br><span class="line">	tree[tree[cur].r].tag ^= <span class="number">1</span>;</span><br><span class="line">	tree[cur].tag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>split 函数</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!cur)</span><br><span class="line">	&#123;</span><br><span class="line">		a = b = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(cur);</span><br><span class="line">	<span class="keyword">if</span> (tree[tree[cur].l].size + <span class="number">1</span> &lt;= val)<span class="comment">//文艺平衡树是按size分的</span></span><br><span class="line">	&#123;</span><br><span class="line">		a = cur;</span><br><span class="line">		<span class="built_in">split</span>(tree[cur].r, tree[cur].r, b, val - tree[tree[cur].l].size - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		b = cur;</span><br><span class="line">		<span class="built_in">split</span>(tree[cur].l, a, tree[cur].l, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">update</span>(cur);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>merge 函数</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>&amp; cur, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!a || !b)</span><br><span class="line">	&#123;</span><br><span class="line">		cur = a + b;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tree[a].rnk &lt;= tree[b].rnk)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pushdown</span>(a);</span><br><span class="line">		cur = a;</span><br><span class="line">		<span class="built_in">merge</span>(tree[a].r, tree[a].r, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pushdown</span>(b);</span><br><span class="line">		cur = b;</span><br><span class="line">		<span class="built_in">merge</span>(tree[b].l, a, tree[b].l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">update</span>(cur);<span class="comment">//记得update，forget to update 3 times</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>reverse 函数</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span>&amp; cur, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">split</span>(cur, a, b, y);</span><br><span class="line">	<span class="built_in">split</span>(a, a, c, x - <span class="number">1</span>);</span><br><span class="line">	tree[c].tag ^= <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">merge</span>(a, a, c);</span><br><span class="line">	<span class="built_in">merge</span>(cur, a, b);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>print 函数</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(x);</span><br><span class="line">	<span class="built_in">print</span>(tree[x].l);</span><br><span class="line">	cout &lt;&lt; tree[x].val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">print</span>(tree[x].r);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例题-2">例题</h3>
<h4 id="洛谷P3391">洛谷P3391</h4>
<p><a href="https://www.luogu.com.cn/problem/P3391">P3391 【模板】文艺平衡树 - 洛谷</a></p>
<h4 id="洛谷P3850">洛谷P3850</h4>
<p><a href="https://www.luogu.com.cn/problem/P3850">P3850 书架</a></p>
<blockquote>
<p>Knuth 先生家里有个精致的书架，书架上有 <em>N</em> 本书，如今他想学到更多的知识，于是又买来了 <em>M</em> 本不同的新书。现在他要把新买的书依次插入到书架中，他已经把每本书要插入的位置标记好了，并且相应的将它们放好。由于 Knuth 年龄已大，过几天他已经记不清某些位置上放的到底是什么书了，请问你能帮助他吗？</p>
</blockquote>
<p>文艺平衡树加一个 <code>string</code> 就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val, l, r, size, rnk, tag;</span><br><span class="line">	string s;</span><br><span class="line">&#125;tree[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">add_node</span>(i);</span><br><span class="line">		tree[a].s = s;</span><br><span class="line">		<span class="built_in">merge</span>(root, root, a);</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; s &gt;&gt; x;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="built_in">add_node</span>(x);</span><br><span class="line">		tree[c].s = s;</span><br><span class="line">		<span class="built_in">split</span>(root, a, b, x);</span><br><span class="line">		<span class="built_in">merge</span>(a, a, c);</span><br><span class="line">		<span class="built_in">merge</span>(root, a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">split</span>(root, a, b, x + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">split</span>(a, a, c, x);</span><br><span class="line">		cout &lt;&lt; tree[c].s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="built_in">merge</span>(a, a, c);</span><br><span class="line">		<span class="built_in">merge</span>(root, a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>平衡树</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>换根DP（二次扫描DP）</title>
    <url>/2025/09/26/%E6%8D%A2%E6%A0%B9DP%EF%BC%88%E4%BA%8C%E6%AC%A1%E6%89%AB%E6%8F%8FDP%EF%BC%89/</url>
    <content><![CDATA[<h1>换根DP（二次扫描DP）</h1>
<h2 id="介绍">介绍</h2>
<p>对于树形DP,若给定无根树，而问题的最优解与根节点相关，那么考虑换根DP。</p>
<p>通常可以将枚举根节点跑DP的时间复杂度由 $O(N^2)$ 降为 $O(N)$。</p>
<span id="more"></span>
<h2 id="换根DP的实现步骤">换根DP的实现步骤</h2>
<ol>
<li>定义 $dp_i$ 表示以 $i$ 为根节点的子树，XXX的最值或方案数；跑一遍从下到上转移的树形DP（$dfs(root)$）；</li>
<li>定义 $f_i$ 表示点 $i$ 为全局根节点的XXX的最值或方案数，并令 $f_1=dp_1$；</li>
<li>再跑一遍从上到下转移的树形DP（$dfs1(root)$）。</li>
</ol>
<h2 id="例题">例题</h2>
<h3 id="洛谷P3478">洛谷P3478</h3>
<p><a href="https://www.luogu.com.cn/problem/P3478">P3478 [POI 2008] STA-Station</a></p>
<p>定义 $dp_i$ 表示以 $i$ 为根节点的子树深度之和最大值。</p>
<p>$$dp_x=dep_x+\sum^{nxt}<em>{nxt\in children_x}dp</em>{nxt}$$</p>
<p>定义 $f_i$ 表示点 $i$ 为全局根节点的深度之和最大值。</p>
<p>设 $f_{nxt}=ff$，则：</p>
<p>$$\begin{aligned}ff &amp; = (f_x-ff)+(n-size_{nxt})+(ff-size_{nxt})\&amp;=f_x-2size_{nxt}+n\end{aligned}$$</p>
<p>当然，这道题因为求的是选择的结点编号，所以可以不设 $dp_i$（不推荐）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, dp[N], f[N], size[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[x] = sum;</span><br><span class="line">	::size[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nxt : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt, x, sum + <span class="number">1</span>);</span><br><span class="line">			::size[x] += ::size[nxt];</span><br><span class="line">			dp[x] += dp[nxt];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nxt : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			f[nxt] = f[x] - <span class="number">2</span> * ::size[nxt] + n;</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	f[<span class="number">1</span>] = dp[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> id = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (f[i] &gt; f[id])</span><br><span class="line">			id = i;</span><br><span class="line">	cout &lt;&lt; id;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷P2986">洛谷P2986</h3>
<p><a href="https://www.luogu.com.cn/problem/P2986">P2986 [USACO10MAR] Great Cow Gathering G</a></p>
<p>定义 $dp_i$ 表示以 $i$ 为根节点的子树每只奶牛去参加集会所走的路程之和。</p>
<p>$$dp_x=\sum^{nxt}<em>{nxt\in children_x}dp</em>{nxt}+w_{x,nxt}size_{nxt}$$</p>
<p>定义 $f_i$ 表示点 $i$ 为全局根节点每只奶牛去参加集会所走的路程之和。</p>
<p>$$f_{nxt}=f_x+w_{x,nxt}(size_1-2size_{nxt})$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, dp[N], a[N], f[N], size[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[x] = <span class="number">0</span>;</span><br><span class="line">	::size[x] = a[x];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt, x, sum + <span class="number">1</span>);</span><br><span class="line">			::size[x] += ::size[nxt];</span><br><span class="line">			dp[x] += w * ::size[nxt] + dp[nxt];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			f[nxt] = f[x] + (::size[<span class="number">1</span>] - <span class="number">2</span> * ::size[nxt]) * w;</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	f[<span class="number">1</span>] = dp[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> id = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (f[i] &lt; f[id])</span><br><span class="line">			id = i;</span><br><span class="line">	cout &lt;&lt; f[id];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CF1187E">CF1187E</h3>
<p><a href="https://codeforces.com/problemset/problem/1187/E">Tree Painting</a>|<a href="https://vjudge.net/problem/CodeForces-1187E#author=DeepSeek_zh">中文翻译</a></p>
<p>定义 $dp_i$ 表示以 $i$ 为根节点的子树获得的总分数。</p>
<p>$$dp_x=dep_x\sum^{nxt}<em>{nxt\in children_x}dp</em>{nxt}$$</p>
<p>定义 $f_i$ 表示点 $i$ 为全局根节点获得的总分数。</p>
<p>$$f_{nxt}=f_x+n-2size_{nxt}$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, dp[N], f[N], size[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[x] = sum;</span><br><span class="line">	::size[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nxt : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt, x, sum + <span class="number">1</span>);</span><br><span class="line">			::size[x] += ::size[nxt];</span><br><span class="line">			dp[x] += dp[nxt];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nxt : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			f[nxt] = f[x] - <span class="number">2</span> * ::size[nxt] + n;</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	f[<span class="number">1</span>] = dp[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> id = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (f[i] &gt; f[id])</span><br><span class="line">			id = i;</span><br><span class="line">	cout &lt;&lt; f[id];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CF1324F">CF1324F</h3>
<p><a href="https://codeforces.com/problemset/problem/1324/F">Maximum White Subtree</a>|<a href="https://vjudge.net/problem/CodeForces-1324F#author=DeepSeek_zh">中文翻译</a></p>
<p>当确定第一个染色节点 $x$ 后, 之后都只能染黑色节点的邻接点；</p>
<p>若 $x$ 作为根，则染色顺序一定是从上到下，且代价确定；</p>
<p>因此，一棵树的代价只和根节点有关，考虑换根DP。</p>
<p>定义 $dp_i$ 表示以 $i$ 为根节点的子树白顶点数与黑顶点数的最大差值。</p>
<p>$$dp_x=\sum^{nxt}<em>{nxt\in children_x}\max(0,dp</em>{nxt})$$</p>
<p>定义 $f_i$ 表示点 $i$ 为全局根节点白顶点数与黑顶点数的最大差值。</p>
<p>$$f_{nxt}=dp_{nxt}+\max(0,f_x-\max(0,dp_{nxt}))$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, dp[N], a[N], f[N], size[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[x] = ::size[x] = a[x];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt, x, sum + <span class="number">1</span>);</span><br><span class="line">			::size[x] += ::size[nxt];</span><br><span class="line">			dp[x] += <span class="built_in">max</span>(<span class="number">0ll</span>, dp[nxt]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			f[nxt] = dp[nxt] + <span class="built_in">max</span>(<span class="number">0ll</span>, f[x] - <span class="built_in">max</span>(<span class="number">0ll</span>, dp[nxt]));</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i], a[i] = a[i] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = <span class="number">1</span>;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	f[<span class="number">1</span>] = dp[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cout &lt;&lt; f[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷U224225">洛谷U224225</h3>
<p><a href="https://www.luogu.com.cn/problem/U224225">U224225 Accumulation Degree</a></p>
<p>定义 $dp_i$ 表示以 $i$ 为根节点的子树水系的流量最大值。</p>
<p>定义 $f_i$ 表示点 $i$ 为全局根节点水系的流量最大值。</p>
<p>状态转移见代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> t, n, dp[N], f[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[x] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt, x, sum + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (nbr[nxt].<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">				dp[x] += w;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dp[x] += <span class="built_in">min</span>(w, dp[nxt]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			f[nxt] = dp[nxt] + <span class="built_in">min</span>(w, f[x] - <span class="built_in">min</span>(w, dp[nxt]));</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			nbr[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x, y, z;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">			nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">			nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		f[<span class="number">1</span>] = dp[<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> id = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (f[i] &gt; f[id])</span><br><span class="line">				id = i;</span><br><span class="line">		cout &lt;&lt; f[id] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷P3761">洛谷P3761</h3>
<p><a href="https://www.luogu.com.cn/problem/P3761">P3761 [TJOI2017] 城市</a></p>
<p>利用<a href="https://www.luogu.com.cn/article/8v2c463v">树的直径</a>的树形DP，求树的中心，就是换根DP。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, dis1[N], dis2[N], up[N], maxi, mini, ans = INT_MAX;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt, x);</span><br><span class="line">			<span class="type">int</span> tmp = dis1[nxt] + w;</span><br><span class="line">			<span class="keyword">if</span> (dis1[x] &lt; tmp)</span><br><span class="line">			&#123;</span><br><span class="line">				dis2[x] = dis1[x];</span><br><span class="line">				dis1[x] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (dis2[x] &lt; tmp)</span><br><span class="line">				dis2[x] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sum = dis1[x] + dis2[x];</span><br><span class="line">	<span class="keyword">if</span> (sum &gt; maxi)</span><br><span class="line">		maxi = sum;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			up[nxt] = up[x] + w;</span><br><span class="line">			<span class="keyword">if</span> (dis1[nxt] + w == dis1[x])</span><br><span class="line">				up[nxt] = <span class="built_in">max</span>(up[nxt], dis2[x] + w);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				up[nxt] = <span class="built_in">max</span>(up[nxt], dis1[x] + w);</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tmp = <span class="built_in">max</span>(up[x], dis1[x]);</span><br><span class="line">	<span class="keyword">if</span> (tmp &lt; mini)</span><br><span class="line">		mini = tmp;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;<span class="built_in">work</span>(<span class="type">int</span> x, <span class="type">int</span> fa)</span><br><span class="line">&#123;</span><br><span class="line">	maxi = <span class="number">0</span>;</span><br><span class="line">	mini = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		dis1[i] = dis2[i] = up[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(x, fa);</span><br><span class="line">	<span class="built_in">dfs1</span>(x, fa);</span><br><span class="line">	<span class="keyword">return</span> &#123; maxi,mini &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; nxt)</span><br><span class="line">			&#123;</span><br><span class="line">				pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;a = <span class="built_in">work</span>(i, nxt), b = <span class="built_in">work</span>(nxt, i);</span><br><span class="line">				ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>(&#123; a.first,b.first,a.second + b.second + w &#125;));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title>状压DP</title>
    <url>/2025/05/02/%E7%8A%B6%E5%8E%8BDP/</url>
    <content><![CDATA[<h1>状压DP</h1>
<blockquote>
<p>状压 DP 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。</p>
<p>——<a href="https://oi.wiki/dp/state/">OI-WIKI</a></p>
</blockquote>
<span id="more"></span>
<p>我们看 <a href="https://www.luogu.com.cn/problem/P10447">P10447 最短 Hamilton 路径</a>：</p>
<blockquote>
<p>给定一张 $n$ 个点的带权无向图，点从 $0 \sim n-1$ 标号，求起点 $0$ 到终点 $n-1$ 的最短 Hamilton 路径。</p>
<p>Hamilton 路径的定义是从 $0$ 到 $n-1$ 不重不漏地经过每个点恰好一次。</p>
</blockquote>
<p>我们发现状态转移需要获取点有没有转移过，所以定义 $dp _ {0/1,0/1,\cdots,0/1,i}$ 表示最后到点 $i$，其他点有没有转移的最短 Hamilton 路径长度。</p>
<p>写 $n+1$ 个循环的代码十分长，能不能让转移更简洁？</p>
<p>这个状态前面特别像二进制整数，我们可以用数表示。</p>
<p>$dp _ {i,j}$ 表示点有没有转移是二进制下 $i$，最后达到 $j$ 的最短 Hamilton 路径的长度。</p>
<p>答案为 $dp _ {2^n-1,n-1}$。</p>
<p>优化：枚举 $i$ 时 $i=i+2$ 而不是 $i=i+1$。</p>
<p>时间复杂度 $O(\frac{2^nn^2}{2})=O(2^{n-1}n^2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, dp[<span class="number">1</span> &lt;&lt; <span class="number">20</span>][N], dis[N][N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			cin &gt;&gt; dis[i][j];</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; (<span class="number">1ll</span> &lt;&lt; n); i += <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">					<span class="keyword">if</span> (((i &gt;&gt; k) &amp; <span class="number">1</span>) &amp;&amp; j != k)</span><br><span class="line">						dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i ^ (<span class="number">1ll</span> &lt;&lt; j)][k] + dis[k][j]);</span><br><span class="line">	cout &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题">例题</h2>
<h3 id="洛谷P1171">洛谷P1171</h3>
<p><a href="https://www.luogu.com.cn/problem/P1171">P1171 售货员的难题</a></p>
<p>和上一题差不多，只是需要回到 $1$ 节点。</p>
<p>可以枚举回去前最后一次到达的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	ans = <span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i] + dis[i][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>剩下的一样。</p>
<h3 id="洛谷P2704">洛谷P2704</h3>
<p><a href="https://www.luogu.com.cn/problem/P2704">P2704 [NOI2001] 炮兵阵地</a></p>
<p>定义 $dp_{i,j,k}$ 表示第 $i$ 行摆放二进制下的 $j$，第 $i-1$ 行摆放二进制下的 $k$ 时最多能摆放的炮兵部队的数量。</p>
<p>答案为 $\max dp_{i,j,k}$。</p>
<p>但是 $100\times4^{10}=104,867,600$ 次状态转移，会 TLE。</p>
<p>优化：实际上有用的 $j,k$ 只有最多 $60$ 个，因此可以预处理有用的 $j,k$。</p>
<p>时间复杂度 $O(nk^2+2^{10})$，其中 $k$ 表示有用的 $j$ 的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], b[N], c[N], cnt, dp[N][<span class="number">65</span>][<span class="number">65</span>], ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> c;</span><br><span class="line">			cin &gt;&gt; c;</span><br><span class="line">			a[i] = (a[i] &lt;&lt; <span class="number">1</span>) + (c == <span class="string">&#x27;P&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++)</span><br><span class="line">		<span class="keyword">if</span> (!((i &lt;&lt; <span class="number">1</span>) &amp; i) &amp;&amp; !((i &lt;&lt; <span class="number">2</span>) &amp; i))</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			b[cnt] = i;</span><br><span class="line">			c[cnt] = __builtin_popcount(i);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)</span><br><span class="line">			<span class="keyword">if</span> ((b[j] | a[i]) == a[i])</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= cnt; k++)</span><br><span class="line">					<span class="keyword">if</span> (!(b[j] &amp; b[k]) &amp;&amp; (b[k] | a[i - <span class="number">1</span>]) == a[i - <span class="number">1</span>])</span><br><span class="line">						<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= cnt; l++)</span><br><span class="line">							<span class="keyword">if</span> (!(b[j] &amp; b[l]))</span><br><span class="line">								ans = <span class="built_in">max</span>(ans, dp[i][j][k] = <span class="built_in">max</span>(dp[i][j][k],</span><br><span class="line">									dp[i - <span class="number">1</span>][k][l] + c[j]));</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷P1896">洛谷P1896</h3>
<p><a href="https://www.luogu.com.cn/problem/P1896">P1896 [SCOI2005] 互不侵犯</a></p>
<p>定义 $dp_{i,j,k}$ 表示第 $i$ 行摆放二进制下的 $j$，一共摆放了 $k$ 个的方案数。</p>
<p>答案为 $\sum dp_{i,j,K}$。</p>
<p>时间复杂度 $O(2^NNK)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dp[N][<span class="number">1</span> &lt;&lt; <span class="number">9</span>][N], ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++)</span><br><span class="line">			<span class="keyword">if</span> (!((j &lt;&lt; <span class="number">1</span>) &amp; j))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> tmp = __builtin_popcount(j);</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); k++)</span><br><span class="line">					<span class="keyword">if</span> (!((j &lt;&lt; <span class="number">1</span>) &amp; k) &amp;&amp; !(j &amp; k) &amp;&amp; !((k &lt;&lt; <span class="number">1</span>) &amp; j))</span><br><span class="line">						<span class="keyword">for</span> (<span class="type">int</span> l = tmp + __builtin_popcount(k); l &lt;= m; l++)</span><br><span class="line">							dp[i][j][l] = dp[i][j][l] + dp[i - <span class="number">1</span>][k][l - tmp];</span><br><span class="line">				<span class="keyword">if</span> (tmp)</span><br><span class="line">					ans += dp[i][j][m];</span><br><span class="line">			&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷P8756">洛谷P8756</h3>
<p><a href="https://www.luogu.com.cn/problem/P8756">P8756 [蓝桥杯 2021 省 AB2] 国际象棋</a></p>
<p>定义 $dp_{i,j,k,l}$ 表示第 $i$ 列摆放二进制下的 $j$，第 $i-1$ 列摆放二进制下的 $k$，一共摆放了 $l$ 个的方案数。</p>
<p>答案为 $\sum dp_{i,j,k,K}$。</p>
<p>时间复杂度 $O(2^NMK)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, dp[N][<span class="number">1</span> &lt;&lt; <span class="number">6</span>][<span class="number">1</span> &lt;&lt; <span class="number">6</span>][<span class="number">25</span>], ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp = __builtin_popcount(j);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); k++)</span><br><span class="line">				<span class="keyword">if</span> (!((k &lt;&lt; <span class="number">2</span>) &amp; j) &amp;&amp; !((j &lt;&lt; <span class="number">2</span>) &amp; k) &amp;&amp; (i &gt; <span class="number">1</span> ? <span class="literal">true</span> : !k))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> tmp1 = __builtin_popcount(k);</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; (<span class="number">1</span> &lt;&lt; n); l++)</span><br><span class="line">						<span class="keyword">if</span> (!((l &lt;&lt; <span class="number">1</span>) &amp; j) &amp;&amp; !((j &lt;&lt; <span class="number">1</span>) &amp; l) &amp;&amp; (i &gt; <span class="number">2</span> ? <span class="literal">true</span> : !l))</span><br><span class="line">							<span class="keyword">for</span> (<span class="type">int</span> x = tmp + tmp1 +</span><br><span class="line">								__builtin_popcount(l); x &lt;= ::k; x++)</span><br><span class="line">								dp[i][j][k][x] = (dp[i][j][k][x] +</span><br><span class="line">									dp[i - <span class="number">1</span>][k][l][x - tmp]) % mod;</span><br><span class="line">					<span class="keyword">if</span> (tmp)</span><br><span class="line">						ans = (ans + dp[i][j][k][::k]) % mod;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SP1700">SP1700</h3>
<p><a href="https://www.luogu.com.cn/problem/SP1700">SP1700 TRSTAGE - Traveling by Stagecoach</a></p>
<p><a href="https://vjudge.net/problem/SPOJ-TRSTAGE#author=DeepSeek_zh">Traveling by Stagecoach - SPOJ TRSTAGE</a></p>
<p>定义 $dp_{i,j}$ 表示到达状态为二进制下的 $i$ 最后到 $j$ 的最短用时。</p>
<p>答案为 $\min dp_{i,b}$。</p>
<p>时间复杂度 $O\left(2^nn(m+k)\right)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, x, y, a[N], b[N][N];</span><br><span class="line"><span class="type">double</span> dp[<span class="number">1</span> &lt;&lt; <span class="number">8</span>][N], ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x &gt;&gt; y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!n)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">			nbr[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x, y;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			cin &gt;&gt; b[x][y];</span><br><span class="line">			b[y][x] = b[x][y];</span><br><span class="line">			nbr[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">			nbr[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">				dp[i][j] = <span class="number">1e9</span>;</span><br><span class="line">		dp[<span class="number">0</span>][x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				<span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nxt : nbr[k])</span><br><span class="line">							dp[i][k] = <span class="built_in">min</span>(dp[i][k], dp[i ^ (<span class="number">1</span> &lt;&lt; j)][nxt] +</span><br><span class="line">								b[k][nxt] * <span class="number">1.00</span> / a[j]);</span><br><span class="line">						<span class="keyword">if</span> (k == y)</span><br><span class="line">							ans = <span class="built_in">min</span>(ans, dp[i][k]);</span><br><span class="line">					&#125;</span><br><span class="line">		<span class="keyword">if</span> (ans == <span class="number">1e9</span>)</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Impossible\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>动态规划</category>
        <category>状态压缩</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/2025/10/02/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<h1>树链剖分</h1>
<p>是一种将一棵树划分为若干条链的思想，划分后每个树上结点恰好在一条链中。</p>
<p>而一条链又可以转化为一段连续的区间，从而将树上问题转换为序列问题。</p>
<span id="more"></span>
<h2 id="树链剖分的常见方式">树链剖分的常见方式</h2>
<ul>
<li>重链剖分</li>
<li>长链剖分</li>
<li>实链剖分</li>
</ul>
<p>以重链剖分最常用。</p>
<h2 id="重链剖分的步骤">重链剖分的步骤</h2>
<ol>
<li>dfs 预处理树上每个点的 $\mathrm{size}_x$；以及重儿子 $\mathrm{son}_x$；</li>
<li>将根结点 $\mathrm{root}$ 视为轻儿子，那么每个轻儿子往下走重儿子形成的链唯一；</li>
<li>再次从 $\mathrm{root}$ 开始 dfs，并给每个结点打时间戳 $\mathrm{dfn}$；以及反向映射 $\mathrm{id}$，先递归到重儿子；</li>
<li>dfs 过程中维护 $\mathrm{top}_i$ 表示点 $i$ 所在的链的链头结点编号，显然对于任意轻儿子 $x$，$\mathrm{top}_x=x$；重儿子 $\mathrm{top}<em>x=\mathrm{top}</em>{\mathrm{fa}_x}$。</li>
</ol>
<h2 id="重链剖分的性质">重链剖分的性质</h2>
<ol>
<li>确定重儿子后，剖分形式唯一；</li>
<li>任意子树的 $\mathrm{dfn}$ 连续；</li>
<li>任意链的 $\mathrm{dfn}$ 连续；</li>
<li>任意一条路径，最多由 $\log_2\mathrm{N}$ 条子链拼接而成；</li>
<li>由 $4$ 可以推出，任意点 $x$ 往上切换 $\log_2\mathrm{N}$ 次链到根结点出发的重链。</li>
</ol>
<h2 id="例题">例题</h2>
<h3 id="洛谷P3379">洛谷P3379</h3>
<p><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA）</a></p>
<p>用树链剖分求最近公共祖先的过程：</p>
<ul>
<li>当 $\mathrm{dep}_{\mathrm{top}<em>x}&gt;\mathrm{dep}</em>{\mathrm{top}<em>y}$，$x\coloneqq \mathrm{fa}</em>{\mathrm{top}_x}$；</li>
<li>当 $\mathrm{dep}_{\mathrm{top}<em>x}\le \mathrm{dep}</em>{\mathrm{top}<em>y}$，$y\coloneqq \mathrm{fa}</em>{\mathrm{top}_y}$；</li>
<li>重复上面的步骤直到 $\mathrm{top}_x=\mathrm{top}_y$。</li>
</ul>
<p>$$\text{最近公共祖先} =<br>
\begin{cases}<br>
x, &amp; \mathrm{dep}_x &lt; \mathrm{dep}_y \<br>
y, &amp; \text{否则}<br>
\end{cases}$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, root, size[N], dep[N], fa[N], top[N], son[N], dfn[N], rdfn[N], id[N], cnt;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxi = <span class="number">0</span>;</span><br><span class="line">	::size[x] = <span class="number">1</span>;</span><br><span class="line">	dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	::fa[x] = fa;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt, x);</span><br><span class="line">			::size[x] += ::size[nxt];</span><br><span class="line">			<span class="keyword">if</span> (::size[nxt] &gt; maxi)</span><br><span class="line">				son[x] = nxt, maxi = ::size[nxt];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = ++cnt;</span><br><span class="line">	id[cnt] = x;</span><br><span class="line">	<span class="keyword">if</span> (son[x])</span><br><span class="line">	&#123;</span><br><span class="line">		top[son[x]] = top[x];</span><br><span class="line">		<span class="built_in">dfs1</span>(son[x], x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span>(nxt != fa &amp;&amp; !top[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			top[nxt] = nxt;</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rdfn[x] = cnt;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; root;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = <span class="number">1</span>;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">	top[root] = root;</span><br><span class="line">	<span class="built_in">dfs1</span>(root, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">lca</span>(x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷P3384">洛谷P3384</h3>
<p><a href="https://www.luogu.com.cn/problem/P3384">P3384 【模板】重链剖分/树链剖分</a></p>
<p>用线段树维护重链剖分后的链的权值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, root, mod, a[N], size[N], dep[N], fa[N], top[N], son[N], dfn[N],</span><br><span class="line">rdfn[N], id[N], tree[N &lt;&lt; <span class="number">2</span>], tag[N &lt;&lt; <span class="number">2</span>], cnt;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[x] = tree[x &lt;&lt; <span class="number">1</span>] + tree[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tag[x] += val;</span><br><span class="line">	tree[x] += (r - l + <span class="number">1</span>) * val;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tag[x])</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">addtag</span>(x &lt;&lt; <span class="number">1</span>, l, mid, tag[x]);</span><br><span class="line">	<span class="built_in">addtag</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, tag[x]);</span><br><span class="line">	tag[x] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[x] = a[id[l]]; <span class="comment">// 不要写成 `tree[x] = a[l]`！</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">	<span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="built_in">pushup</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> qx, <span class="type">int</span> qy, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (qy &lt; l || qx &gt; r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= l &amp;&amp; qy &gt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">addtag</span>(x, l, r, val);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(x, l, r);</span><br><span class="line">	<span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, l, mid, qx, qy, val);</span><br><span class="line">	<span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, qx, qy, val);</span><br><span class="line">	<span class="built_in">pushup</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> qx, <span class="type">int</span> qy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (qy &lt; l || qx &gt; r)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= l &amp;&amp; qy &gt;= r)</span><br><span class="line">		<span class="keyword">return</span> tree[x];</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(x, l, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, mid, qx, qy) + <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, qx, qy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxi = <span class="number">0</span>;</span><br><span class="line">	::size[x] = <span class="number">1</span>;</span><br><span class="line">	dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	::fa[x] = fa;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt, x);</span><br><span class="line">			::size[x] += ::size[nxt];</span><br><span class="line">			<span class="keyword">if</span> (::size[nxt] &gt; maxi)</span><br><span class="line">				son[x] = nxt, maxi = ::size[nxt];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = ++cnt;</span><br><span class="line">	id[cnt] = x;</span><br><span class="line">	<span class="keyword">if</span> (son[x])</span><br><span class="line">	&#123;</span><br><span class="line">		top[son[x]] = top[x];</span><br><span class="line">		<span class="built_in">dfs1</span>(son[x], x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span>(nxt != fa &amp;&amp; !top[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			top[nxt] = nxt;</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rdfn[x] = cnt;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_path</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x], val);</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[y]], dfn[y], val);</span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">		<span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[y], val);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_path</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">		&#123;</span><br><span class="line">			sum += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x]);</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			sum += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[y]], dfn[y]);</span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">		<span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> sum + <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; root &gt;&gt; mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i], a[i] %= mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = <span class="number">1</span>;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">	top[root] = root;</span><br><span class="line">	<span class="built_in">dfs1</span>(root, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> opt, x, y, z;</span><br><span class="line">		cin &gt;&gt; opt &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; y &gt;&gt; z;</span><br><span class="line">			<span class="built_in">update_path</span>(x, y, z % mod);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; y;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query_path</span>(x, y) % mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; z;</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], rdfn[x], z % mod);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], rdfn[x]) % mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷P1505">洛谷P1505</h3>
<p><a href="https://www.luogu.com.cn/problem/P1505">P1505 [国家集训队] 旅游</a></p>
<p>把边权放到子结点，从而将边的问题转换成点的问题。</p>
<p>线段树同时维护边权和、边权最大值、边权最小值，<code>N</code> 操作可以直接交换边权最大值、边权最小值并取反。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, root = <span class="number">1</span>, a[N], b[N], c[N], size[N], dep[N], fa[N],</span><br><span class="line">top[N], son[N], dfn[N], rdfn[N], id[N], cnt;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">	<span class="type">bool</span> f1, f2;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	node1 <span class="keyword">operator</span>+=(<span class="type">const</span> node1&amp; u) <span class="comment">// 不要把懒标记合并直接写成覆盖！</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (u.f1)</span><br><span class="line">			*<span class="keyword">this</span> = u;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (u.f2)</span><br><span class="line">			<span class="keyword">if</span> (f1)</span><br><span class="line">				x = -x;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				f2 = !f2;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!() <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> !f1 &amp;&amp; !f2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tag[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> sum, maxi, mini, len;</span><br><span class="line">	node <span class="keyword">operator</span>+(<span class="type">const</span> node&amp; u) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123; (sum + u.sum),<span class="built_in">max</span>(maxi, u.maxi),</span><br><span class="line">			<span class="built_in">min</span>(mini, u.mini),len + u.len &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	node <span class="keyword">operator</span>+=(<span class="type">const</span> node&amp; u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + u;</span><br><span class="line">	&#125;</span><br><span class="line">	node <span class="keyword">operator</span>+=(<span class="type">const</span> node1&amp; u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (u.f1)</span><br><span class="line">			sum = u.x * len, maxi = u.x, mini = u.x;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (u.f2)</span><br><span class="line">			sum = -sum, <span class="built_in">swap</span>(maxi, mini), maxi = -maxi, mini = -mini;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[x] = tree[x &lt;&lt; <span class="number">1</span>] + tree[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, node1 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tag[x] += val;</span><br><span class="line">	tree[x] += val;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tag[x])</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">addtag</span>(x &lt;&lt; <span class="number">1</span>, l, mid, tag[x]);</span><br><span class="line">	<span class="built_in">addtag</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, tag[x]);</span><br><span class="line">	tag[x] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[x] = &#123; a[id[l]],a[id[l]],a[id[l]],<span class="number">1</span> &#125;;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">	<span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="built_in">pushup</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> qx, <span class="type">int</span> qy, node1 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (qy &lt; l || qx &gt; r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= l &amp;&amp; qy &gt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">addtag</span>(x, l, r, val);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(x, l, r);</span><br><span class="line">	<span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, l, mid, qx, qy, val);</span><br><span class="line">	<span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, qx, qy, val);</span><br><span class="line">	<span class="built_in">pushup</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> qx, <span class="type">int</span> qy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (qy &lt; l || qx &gt; r)</span><br><span class="line">		<span class="keyword">return</span> &#123; <span class="number">0</span>,(<span class="type">int</span>)<span class="number">-1e9</span>,(<span class="type">int</span>)<span class="number">1e9</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= l &amp;&amp; qy &gt;= r)</span><br><span class="line">		<span class="keyword">return</span> tree[x];</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(x, l, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, mid, qx, qy) +</span><br><span class="line">		<span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, qx, qy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxi = <span class="number">0</span>;</span><br><span class="line">	::size[x] = <span class="number">1</span>;</span><br><span class="line">	dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	::fa[x] = fa;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			a[nxt] = b[w];</span><br><span class="line">			c[w] = nxt;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt, x);</span><br><span class="line">			::size[x] += ::size[nxt];</span><br><span class="line">			<span class="keyword">if</span> (::size[nxt] &gt; maxi)</span><br><span class="line">				son[x] = nxt, maxi = ::size[nxt];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = ++cnt;</span><br><span class="line">	id[cnt] = x;</span><br><span class="line">	<span class="keyword">if</span> (son[x])</span><br><span class="line">	&#123;</span><br><span class="line">		top[son[x]] = top[x];</span><br><span class="line">		<span class="built_in">dfs1</span>(son[x], x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa &amp;&amp; !top[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			top[nxt] = nxt;</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rdfn[x] = cnt;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_path</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, node1 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x], val);</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[y]], dfn[y], val);</span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">		<span class="built_in">swap</span>(x, y);</span><br><span class="line">	<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x] + <span class="number">1</span>, dfn[y], val);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query_path</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node sum = &#123; <span class="number">0</span>,(<span class="type">int</span>)<span class="number">-1e9</span>,(<span class="type">int</span>)<span class="number">1e9</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">		&#123;</span><br><span class="line">			sum += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x]);</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			sum += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[y]], dfn[y]);</span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">		<span class="built_in">swap</span>(x, y);</span><br><span class="line">	<span class="keyword">return</span> sum + <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x] + <span class="number">1</span>, dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = i;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; b[i];</span><br><span class="line">		x++;</span><br><span class="line">		y++;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">	top[root] = root;</span><br><span class="line">	<span class="built_in">dfs1</span>(root, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string opt;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="string">&quot;C&quot;</span>)</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[c[x]], dfn[c[x]], &#123; <span class="literal">true</span>,<span class="literal">false</span>,y &#125;);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&quot;N&quot;</span>)</span><br><span class="line">			<span class="built_in">update_path</span>(++x, ++y, &#123; <span class="literal">false</span>,<span class="literal">true</span>,<span class="number">0</span> &#125;);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&quot;SUM&quot;</span>)</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query_path</span>(++x, ++y).sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&quot;MAX&quot;</span>)</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query_path</span>(++x, ++y).maxi &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&quot;MIN&quot;</span>)</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query_path</span>(++x, ++y).mini &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷P2590">洛谷P2590</h3>
<p><a href="https://www.luogu.com.cn/problem/P2590">P2590 [ZJOI2008] 树的统计</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, root = <span class="number">1</span>, a[N], size[N], dep[N], fa[N],</span><br><span class="line">top[N], son[N], dfn[N], rdfn[N], id[N], cnt;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span> &#123;</span><br><span class="line">	<span class="type">bool</span> f1;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	node1 <span class="keyword">operator</span>+=(<span class="type">const</span> node1&amp; u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span> = u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!() <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> !f1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tag[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> sum, maxi, len;</span><br><span class="line">	node <span class="keyword">operator</span>+(<span class="type">const</span> node&amp; u) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123; (sum + u.sum),<span class="built_in">max</span>(maxi, u.maxi),len + u.len &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	node <span class="keyword">operator</span>+=(<span class="type">const</span> node&amp; u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + u;</span><br><span class="line">	&#125;</span><br><span class="line">	node <span class="keyword">operator</span>+=(<span class="type">const</span> node1&amp; u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (u.f1)</span><br><span class="line">			sum = u.x * len, maxi = u.x;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[x] = tree[x &lt;&lt; <span class="number">1</span>] + tree[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, node1 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tag[x] += val;</span><br><span class="line">	tree[x] += val;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tag[x])</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">addtag</span>(x &lt;&lt; <span class="number">1</span>, l, mid, tag[x]);</span><br><span class="line">	<span class="built_in">addtag</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, tag[x]);</span><br><span class="line">	tag[x] = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[x] = &#123; a[id[l]],a[id[l]],<span class="number">1</span> &#125;;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">	<span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="built_in">pushup</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> qx, <span class="type">int</span> qy, node1 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (qy &lt; l || qx &gt; r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= l &amp;&amp; qy &gt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">addtag</span>(x, l, r, val);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(x, l, r);</span><br><span class="line">	<span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, l, mid, qx, qy, val);</span><br><span class="line">	<span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, qx, qy, val);</span><br><span class="line">	<span class="built_in">pushup</span>(x);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> qx, <span class="type">int</span> qy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (qy &lt; l || qx &gt; r)</span><br><span class="line">		<span class="keyword">return</span> &#123; <span class="number">0</span>,(<span class="type">int</span>)<span class="number">-1e9</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= l &amp;&amp; qy &gt;= r)</span><br><span class="line">		<span class="keyword">return</span> tree[x];</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(x, l, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, mid, qx, qy) +</span><br><span class="line">		<span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, qx, qy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxi = <span class="number">0</span>;</span><br><span class="line">	::size[x] = <span class="number">1</span>;</span><br><span class="line">	dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	::fa[x] = fa;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(nxt, x);</span><br><span class="line">			::size[x] += ::size[nxt];</span><br><span class="line">			<span class="keyword">if</span> (::size[nxt] &gt; maxi)</span><br><span class="line">				son[x] = nxt, maxi = ::size[nxt];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = ++cnt;</span><br><span class="line">	id[cnt] = x;</span><br><span class="line">	<span class="keyword">if</span> (son[x])</span><br><span class="line">	&#123;</span><br><span class="line">		top[son[x]] = top[x];</span><br><span class="line">		<span class="built_in">dfs1</span>(son[x], x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa &amp;&amp; !top[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			top[nxt] = nxt;</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rdfn[x] = cnt;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_path</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, node1 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x], val);</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[y]], dfn[y], val);</span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">		<span class="built_in">swap</span>(x, y);</span><br><span class="line">	<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[y], val);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query_path</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node sum = &#123; <span class="number">0</span>,(<span class="type">int</span>)<span class="number">-1e9</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">		&#123;</span><br><span class="line">			sum += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x]);</span><br><span class="line">			x = fa[top[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			sum += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[y]], dfn[y]);</span><br><span class="line">			y = fa[top[y]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">		<span class="built_in">swap</span>(x, y);</span><br><span class="line">	<span class="keyword">return</span> sum + <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = i;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">	top[root] = root;</span><br><span class="line">	<span class="built_in">dfs1</span>(root, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string opt;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="string">&quot;CHANGE&quot;</span>)</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[x], &#123; <span class="literal">true</span>,y &#125;);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&quot;QMAX&quot;</span>)</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query_path</span>(x, y).maxi &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&quot;QSUM&quot;</span>)</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query_path</span>(x, y).sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>树链剖分</category>
        <category>算法思想</category>
        <category>重链剖分</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>重链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>状压DP（二）</title>
    <url>/2025/05/03/%E7%8A%B6%E5%8E%8BDP%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1>状压DP（二）</h1>
<h2 id="洛谷P3092">洛谷P3092</h2>
<p><a href="https://www.luogu.com.cn/problem/P3092">P3092 [USACO13NOV] No Change G</a></p>
<p>这道题，我们一般定义 $dp_{i,j}$ 为硬币使用了二进制下的 $i$，付到第 $j$ 个人的最多剩下多少钱。</p>
<p>不过 $2^{16}\times 10^5=6,553,600,000$，会超过空间限制。</p>
<p>我们发现“最多剩下多少钱”没有用，因为可以通过使用情况算出。</p>
<p>定义新的状态 $dp_{i}$ 表示硬币使用了二进制下的 $i$ 的最多能付到的人，可以通过前缀和加二分优化计算。</p>
<span id="more"></span>
<p>答案需要枚举。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dp[<span class="number">1</span> &lt;&lt; <span class="number">16</span>], a[N], b[N], sum[N], sum1, ans = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; a[i], sum1 += a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		cin &gt;&gt; b[i], sum[i] = sum[i - <span class="number">1</span>] + b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span>&amp; tmp = dp[i ^ (<span class="number">1</span> &lt;&lt; j)];</span><br><span class="line">				<span class="type">int</span> l = tmp - <span class="number">1</span>, r = m + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (sum[mid] - sum[tmp] &lt;= a[j])</span><br><span class="line">						l = mid;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						r = mid;</span><br><span class="line">				&#125;</span><br><span class="line">				dp[i] = <span class="built_in">max</span>(dp[i], l);</span><br><span class="line">				sum2 += a[j];</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] == m)</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, sum1 - sum2);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P5911">洛谷P5911</h2>
<p><a href="https://www.luogu.com.cn/problem/P5911">P5911 [POI 2004] PRZ - 洛谷</a></p>
<p>定义 $dp_i$ 表示已经过桥的队员为二进制下的 $i$ 的最小过桥时间。</p>
<p>状态转移：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++)</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; j) == j &amp;&amp; sum[j] &lt;= m)</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i ^ j] + maxi[j]);</span><br></pre></td></tr></table></figure>
<p>答案为 $dp_{2^n-1}$。</p>
<p>时间复杂度为 $O(4^n)$。</p>
<p>等一等，$4^{16}=4,294,967,296\gt \text{一秒内可以跑的循环次数}$。</p>
<p>考虑优化，如何不枚举无效状态（也就是只枚举子集）？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j; j = (j - <span class="number">1</span>) &amp; i)</span><br></pre></td></tr></table></figure>
<p>为什么正确？</p>
<p>可以通过模拟验证：</p>
<blockquote>
<p>设 $i={(114)}_{10}={(01110010)}_2$。</p>
<p>第二次枚举时， $j=\left({(01110010)}_2-1\right)\operatorname{and}{(01110010)}_2={(01110000)}_2$。</p>
<p>第三次枚举时， $j=\left({(01110000)}_2-1\right)\operatorname{and}{(01110010)}_2={(01101111)}_2\operatorname{and}{(01110010)}_2={(01100010)}_2$。</p>
<p>$\cdots$</p>
<p>以此类推。</p>
<p>我们发现下枚举总是小于这一次的最大的有效状态。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">16</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dp[<span class="number">1</span> &lt;&lt; <span class="number">16</span>], a[N], b[N], sum[<span class="number">1</span> &lt;&lt; <span class="number">16</span>], maxi[<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++)</span><br><span class="line">			<span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">				sum[j] += b[i], maxi[j] = <span class="built_in">max</span>(maxi[j], a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j; j = (j - <span class="number">1</span>) &amp; i)</span><br><span class="line">			<span class="keyword">if</span> (sum[j] &lt;= m)</span><br><span class="line">				dp[i] = <span class="built_in">min</span>(dp[i], dp[i ^ j] + maxi[j]);</span><br><span class="line">	cout &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 $O(3^n)$。</p>
<p>为什么？</p>
<p>证明方法一：</p>
<blockquote>
<p>每个队员有以下可以枚举的状态：</p>
<ol>
<li>没有；</li>
<li>$i$ 中有；</li>
<li>$i,j$ 中都有。</li>
</ol>
<p>因此是 $O(3^n)$</p>
</blockquote>
<p>证明方法二：</p>
<blockquote>
<p>前置知识：</p>
<blockquote>
<p><a href="https://oi-wiki.org/math/combinatorics/combination/#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86">二项式定理</a>：</p>
<p>$$\displaystyle(x+y)^n=\sum^n_{i=0}\operatorname{C}^i_nx^iy^{n-i}$$</p>
</blockquote>
<p>总枚举次数为 $\displaystyle\sum_{i=0}^{2^n}2^{\operatorname{popcount}i}$，其中 $\operatorname{popcount}i$ 为二进制下的 $i$ 的 $1$ 的个数。</p>
<p>$$\begin{aligned}\sum_{i=0}^{2^n}2^{\operatorname{popcount}i}&amp;=\sum_{i=0}^n\operatorname{C}^i_n 2^n\&amp;=\sum_{i=0}^n\operatorname{C}^i_n 2^n\times1\&amp;=(2+1)^n\&amp;=3^n\end{aligned}$$</p>
</blockquote>
<h2 id="洛谷P3694">洛谷P3694</h2>
<p><a href="https://www.luogu.com.cn/problem/P3694">P3694 邦邦的大合唱站队</a></p>
<p>考虑状态 $dp_i$ 为已经排好的乐队为二进制下的 $i$ 的出列人数，用前缀和辅助动态规划。</p>
<p>答案为 $dp_{2^m-1}$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dp[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], a[N], sum[N][<span class="number">20</span>], sum1[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">			sum[i][j] = sum[i - <span class="number">1</span>][j];</span><br><span class="line">		sum[i][--a[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">			<span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sum1[i] = sum1[i ^ (<span class="number">1</span> &lt;&lt; j)] + sum[n][j];</span><br><span class="line">				<span class="type">int</span> l = sum1[i ^ (<span class="number">1</span> &lt;&lt; j)] + <span class="number">1</span>, r = l + sum[n][j] - <span class="number">1</span>;</span><br><span class="line">				dp[i] = <span class="built_in">min</span>(dp[i], dp[i ^ (<span class="number">1</span> &lt;&lt; j)] + sum[n][j] -</span><br><span class="line">					sum[r][j] + sum[l - <span class="number">1</span>][j]);</span><br><span class="line">			&#125;</span><br><span class="line">	cout &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P10449">洛谷P10449</h2>
<p><a href="https://www.luogu.com.cn/problem/P10449">P10449 费解的开关</a></p>
<p>对于每一组数据，我们暴力还原，时间复杂度 $O(26^6n)=O(n)$，常数十分大。</p>
<p>为什么不预处理呢？</p>
<p>为了方便存储，我们状态压缩数组，使用 dfs/bfs 搜索。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> t, dx[] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> z, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span> (nx &lt; <span class="number">6</span> &amp;&amp; nx &amp;&amp; ny &lt; <span class="number">6</span> &amp;&amp; ny)</span><br><span class="line">			z ^= <span class="number">1</span> &lt;&lt; ((nx - <span class="number">1</span>) * <span class="number">5</span> + ny - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z = (<span class="number">1</span> &lt;&lt; <span class="number">25</span>) - <span class="number">1</span>, <span class="type">int</span> sum = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sum &gt; <span class="number">6</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	mp[z] = sum;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">6</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(x + !(y % <span class="number">5</span>), y % <span class="number">5</span> + <span class="number">1</span>, z, sum);</span><br><span class="line">	<span class="built_in">dfs</span>(x + !(y % <span class="number">5</span>), y % <span class="number">5</span> + <span class="number">1</span>, <span class="built_in">work</span>(z, x, y), sum + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">25</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> c;</span><br><span class="line">			cin &gt;&gt; c;</span><br><span class="line">			sum |= (c - <span class="string">&#x27;0&#x27;</span>) &lt;&lt; (<span class="number">25</span> - i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!mp.<span class="built_in">count</span>(sum))</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; mp[sum] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>动态规划</category>
        <category>状态压缩</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流之最小割问题</title>
    <url>/2025/09/17/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B9%8B%E6%9C%80%E5%B0%8F%E5%89%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1>最小割问题</h1>
<p>对于给定的网络流模型，其最小割是指删除边权和最小的边集，使得 $s$ 到 $t$ 不连通。</p>
<p>最小割等于最大流，因为增广路的流量限制是由这些权值的边，方案不一定唯一。</p>
<span id="more"></span>
<h2 id="例题">例题</h2>
<h3 id="洛谷P2774">洛谷P2774</h3>
<p><a href="https://www.luogu.com.cn/problem/P2774">P2774 方格取数问题</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, t, edge[N], level[N], tmp[N], cnt, sum, ans, dx[] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;,</span><br><span class="line">dy[] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(level, <span class="number">0</span>, <span class="keyword">sizeof</span> level);</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	level[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		tmp[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nxt : nbr[x])</span><br><span class="line">			<span class="keyword">if</span> (edge[nxt.second] &amp;&amp; !level[nxt.first])</span><br><span class="line">			&#123;</span><br><span class="line">				level[nxt.first] = level[x] + <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(nxt.first);</span><br><span class="line">				<span class="keyword">if</span> (nxt.first == t)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == t)</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	<span class="type">int</span> rest = flow;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = tmp[x]; i &lt; nbr[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp[x]++;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = nbr[x][i];</span><br><span class="line">		<span class="keyword">if</span> (edge[nxt.second] &amp;&amp; level[nxt.first] == level[x] + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> inc = <span class="built_in">dinic</span>(nxt.first, <span class="built_in">min</span>(rest, edge[nxt.second]));</span><br><span class="line">			edge[nxt.second] -= inc;</span><br><span class="line">			edge[nxt.second ^ <span class="number">1</span>] += inc;</span><br><span class="line">			rest -= inc;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!rest)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(flow - rest))</span><br><span class="line">		level[x] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	s = cnt = <span class="number">1</span>, t = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> z;</span><br><span class="line">			cin &gt;&gt; z;</span><br><span class="line">			sum += z;</span><br><span class="line">			<span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x = s, y = (i - <span class="number">1</span>) * m + j + <span class="number">2</span>;</span><br><span class="line">				edge[++cnt] = z;</span><br><span class="line">				nbr[x].<span class="built_in">push_back</span>(&#123; y,cnt &#125;);</span><br><span class="line">				nbr[y].<span class="built_in">push_back</span>(&#123; x,++cnt &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x = (i - <span class="number">1</span>) * m + j + <span class="number">2</span>, y = t;</span><br><span class="line">				edge[++cnt] = z;</span><br><span class="line">				nbr[x].<span class="built_in">push_back</span>(&#123; y,cnt &#125;);</span><br><span class="line">				nbr[y].<span class="built_in">push_back</span>(&#123; x,++cnt &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> nx = i + dx[k], ny = j + dy[k];</span><br><span class="line">					<span class="keyword">if</span> (nx &gt; <span class="number">0</span> &amp;&amp; ny &gt; <span class="number">0</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">int</span> x = (i - <span class="number">1</span>) * m + j + <span class="number">2</span>, y = (nx - <span class="number">1</span>) * m + ny + <span class="number">2</span>, z = INT_MAX;</span><br><span class="line">						edge[++cnt] = z;</span><br><span class="line">						nbr[x].<span class="built_in">push_back</span>(&#123; y,cnt &#125;);</span><br><span class="line">						nbr[y].<span class="built_in">push_back</span>(&#123; x,++cnt &#125;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line">		ans += <span class="built_in">dinic</span>(s, INT_MAX);</span><br><span class="line">	cout &lt;&lt; sum - ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>网络流</category>
        <category>最小割</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最小割问题</tag>
      </tags>
  </entry>
  <entry>
    <title>赛前训练2-连通性系列问题——总结</title>
    <url>/2025/09/18/%E8%B5%9B%E5%89%8D%E8%AE%AD%E7%BB%832-%E8%BF%9E%E9%80%9A%E6%80%A7%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1>赛前训练2-连通性系列问题——总结</h1>
<h2 id="A">A</h2>
<p><a href="https://www.luogu.com.cn/problem/P2656">洛谷P2656</a></p>
<h3 id="错误原因">错误原因</h3>
<p><code>double</code> 的精度不够，应开 <code>long double</code>。</p>
<h3 id="正解">正解</h3>
<ol>
<li>条边只有在环上时，才可能多次经过，且一定会经过足够次直到边权为 $0$；</li>
<li>输入时维护 <code>x[i]</code>,<code>y[i]</code>,<code>w[i]</code>,<code>kw[i]</code> 其中 <code>kw[i]</code> 表示第i涤边迭代经过的总边权和；</li>
<li>缩点建新DAG图，跑最长路。</li>
</ol>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> double long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, dfn[N], low[N], scc[N], sum[N], num, cnt, ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;st;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> nxt, w, w1;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;nbr[N], new_nbr[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x)</span><br><span class="line">		sum += x, x *= y;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num, vis[x] = <span class="literal">true</span>;</span><br><span class="line">	st.<span class="built_in">push_back</span>(x);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.nxt, &amp; w = y.w, &amp; w1 = y.w1;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(nxt);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[nxt]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vis[nxt])</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[nxt]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[x] == low[x])</span><br><span class="line">	&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">while</span> (st.<span class="built_in">back</span>() != x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp = st.<span class="built_in">back</span>();</span><br><span class="line">			st.<span class="built_in">pop_back</span>();</span><br><span class="line">			vis[tmp] = <span class="literal">false</span>;</span><br><span class="line">			scc[tmp] = cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		st.<span class="built_in">pop_back</span>();</span><br><span class="line">		vis[x] = <span class="literal">false</span>;</span><br><span class="line">		scc[x] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans = <span class="built_in">max</span>(ans, sum += ::sum[x]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : new_nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.nxt, &amp; w = y.w, &amp; w1 = y.w1;</span><br><span class="line">		<span class="built_in">dfs</span>(nxt, sum + w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z;</span><br><span class="line">		<span class="type">double</span> u;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; u;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z,<span class="built_in">work</span>(z, u) &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i])</span><br><span class="line">			<span class="built_in">tarjan</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span>&amp; nxt = y.nxt, &amp; w = y.w, &amp; w1 = y.w1;</span><br><span class="line">			<span class="keyword">if</span> (scc[i] != scc[nxt])</span><br><span class="line">				new_nbr[scc[i]].<span class="built_in">push_back</span>(&#123; scc[nxt],w,w1 &#125;);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				sum[scc[i]] += w1;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(scc[s], <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B">B</h2>
<p><a href="https://codeforces.com/problemset/problem/1000/E">CF1000E</a></p>
<h3 id="思路">思路</h3>
<ul>
<li>跑求割边的 tarjan，再把每一个边双连通分量缩成一个点，最后求树的直径。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, root, num, dfn[N], low[N], dcc[N], cnt, dis;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;nbr[N], new_nbr[N];</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, &amp; w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(nxt, w);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[nxt]);</span><br><span class="line">			cut[w] |= low[nxt] &gt; dfn[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (w != edge)</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[nxt]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dcc[x] = cnt;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (!cut[w] &amp;&amp; !dcc[nxt])</span><br><span class="line">			<span class="built_in">dfs</span>(nxt);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span>&amp; to, <span class="type">int</span> sum = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sum &gt;= dis)</span><br><span class="line">	&#123;</span><br><span class="line">		to = x;</span><br><span class="line">		dis = sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : new_nbr[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span>&amp; nxt = y.first, w = y.second;</span><br><span class="line">		<span class="keyword">if</span> (nxt != fa)</span><br><span class="line">			<span class="built_in">dfs1</span>(nxt, x, to, sum + <span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,i &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,i &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i])</span><br><span class="line">			root = i, <span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dcc[i])</span><br><span class="line">			cnt++, <span class="built_in">dfs</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : nbr[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span>&amp; nxt = y.first, w = y.second;</span><br><span class="line">			<span class="keyword">if</span> (dcc[i] != dcc[nxt])</span><br><span class="line">				new_nbr[dcc[i]].<span class="built_in">push_back</span>(&#123; dcc[nxt],w &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>, x);</span><br><span class="line">	dis = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs1</span>(x, <span class="number">0</span>, y);</span><br><span class="line">	cout &lt;&lt; dis;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C">C</h2>
<p><a href="https://codeforces.com/problemset/problem/1763/E">CF1763E</a></p>
<h3 id="错误原因-2">错误原因</h3>
<p>dp的状态转移方程写错了。</p>
<h3 id="正解-2">正解</h3>
<ol>
<li>有向图的点对只有三种关系：单向对、双向对、不连通；</li>
<li>p可达图就是要构造恰好 $p$ 组点对是强连通的有向图；</li>
<li>给定 $i$ 个点，强连通的点对数介于 $\left[0,\frac{i(i-1)}{2}\right]$；</li>
<li>要追求恰好 $p$ 组强连通点对，那么构造的图应该是若干 scc 的图；</li>
<li>把 scc 看作物品，把 $\frac{ {size} ({size}-1) } {2}$ 看作重量，把点数 ${size}$ 看作价值，问题转化为放满容量为 $p$ 的背包的最小价值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, dp[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)	</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] = INT_MAX;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; ; j++)</span><br><span class="line">			<span class="keyword">if</span> (j * (j - <span class="number">1</span>) / <span class="number">2</span> &lt;= i)</span><br><span class="line">				dp[i] = <span class="built_in">min</span>(dp[i], j + dp[i - j * (j - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; dp[n] * (dp[n] - <span class="number">1</span>) / <span class="number">2</span> - n;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D">D</h2>
<p><a href="https://codeforces.com/problemset/problem/1761/E">CF1761E</a></p>
<h3 id="错误原因-3">错误原因</h3>
<p>写了假解。</p>
<h3 id="正解-3">正解</h3>
<ol>
<li>选择点 $x$ 操作时，尽可能不要让 $×$ 从原本的连通块分离；</li>
<li>当 $x$ 和所在连通块的每个都连了边时，$x$才会分离；</li>
<li>只要是存在非完全图，那么就一定可以选出点 $x$，使得至多操作 $1$ 次完成任务；</li>
<li>而后分类讨论：
<ul>
<li>本来连通：$0$ 次；</li>
<li>不连通
<ul>
<li>只有完全图
<ul>
<li>$2$ 个完全图，每个操作等价于每次移动 $1$ 个点到另一个完全图：$\min({size}_1,{size}_2)$；</li>
<li>$&gt;2$ 个完全图：$2$ 次</li>
</ul>
</li>
<li>存在非完全图：$1$ 次。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> t, n, in[N], fa[N], size[N], sum[N], cnt, tot;</span><br><span class="line"><span class="type">char</span> c[N][N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionn</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x);</span><br><span class="line">	y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x != y)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[x] = y;</span><br><span class="line">		::size[y] += ::size[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		ans.<span class="built_in">clear</span>();</span><br><span class="line">		cnt = tot = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			fa[i] = i, ::size[i] = <span class="number">1</span>, sum[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			in[i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				cin &gt;&gt; c[i][j];</span><br><span class="line">				<span class="keyword">if</span> (c[i][j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					in[i]++;</span><br><span class="line">					<span class="built_in">unionn</span>(i, j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (in[i] == ::size[<span class="built_in">find</span>(i)] - <span class="number">1</span>)</span><br><span class="line">				sum[<span class="built_in">find</span>(i)]++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (fa[i] == i)</span><br><span class="line">				<span class="keyword">if</span> (sum[i] == ::size[i] &amp;&amp; ::size[i] &gt; <span class="number">1</span>)</span><br><span class="line">					cnt++;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					tot++;</span><br><span class="line">		<span class="keyword">if</span> (cnt + tot == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tot)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">				<span class="keyword">if</span> (in[i] &lt; ::size[<span class="built_in">find</span>(i)] - <span class="number">1</span> || !in[i])</span><br><span class="line">					<span class="keyword">if</span> (n - in[i] &gt; n - in[pos] || !pos)</span><br><span class="line">						pos = i;</span><br><span class="line">			ans.<span class="built_in">push_back</span>(pos);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">				<span class="keyword">if</span> (sum[<span class="built_in">find</span>(i)] &lt; sum[<span class="built_in">find</span>(pos)])</span><br><span class="line">					pos = <span class="built_in">find</span>(i);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">find</span>(pos) == <span class="built_in">find</span>(i))</span><br><span class="line">					ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">			ans.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">find</span>(i) != <span class="built_in">find</span>(pos))</span><br><span class="line">				&#123;</span><br><span class="line">					ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : ans)</span><br><span class="line">			cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>总结</category>
        <category>连通性问题</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>连通性问题</tag>
      </tags>
  </entry>
  <entry>
    <title>连通性问题</title>
    <url>/2024/12/31/%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1>连通性问题</h1>
<blockquote>
<p>tarjan：连通性问题永远的神。</p>
</blockquote>
<h2 id="双连通与割点、割边">双连通与割点、割边</h2>
<ul>
<li>
<p>点双连通：在无向图中，删除一个点（不是 $x$ 或者 $y$）后，点 $x$ 和点 $y$ 仍然能够彼此到达，那么称 $x$ 和 $y$ 是点双连通的；</p>
</li>
<li>
<p>边双连通：在无向图中，删除一条边后，点 $x$ 和点 $y$ 仍然能够彼此到达，那么称 $x$ 和 $y$ 是边双连通的；</p>
</li>
<li>
<p>性质 $1$： 点双连通不具有传递性，但边双连通具有传递性；</p>
</li>
</ul>
<span id="more"></span>
<ul>
<li>
<p>割点</p>
<ul>
<li>
<p>在无向图 $G$ 中，若删除 $x$ 后，连通块的数量增加，则 $x$ 称为无向图 $G$ 的一个割点（割顶）。</p>
</li>
<li>
<p>结论：至少有 $3$ 个点的无向图，才<strong>可能</strong>存在割点；</p>
</li>
<li>
<p>割点的判定</p>
<ul>
<li>若搜索树中，有从 $x$ 到 $y$ 的连边，当 $low_y \ge dfn_x$ 时，说明 $y$ 能到达的最小时间戳在 $x$ 的时间戳之上，$y$ 被 $x$ 与 $x$ 之前的结点“隔开”，$x$ 可能是割点。只要 $x$ 不是搜索树的根结点，或者 $x$ 是根结点，但是 $x$ 的子结点大于 $1$ 个，那么 $x$ 就是割点。</li>
<li>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num; <span class="comment">//打时间戳</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">//统计子 结点个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : nbr[x])</span><br><span class="line">        <span class="keyword">if</span> (!dfn[nxt]) <span class="comment">//没去过 $nxt$</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(nxt); <span class="comment">//递归查找</span></span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[nxt]); <span class="comment">//维护 $x$ 能达到的最小时间戳 $low_X$</span></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (low[nxt] &gt;= dfn[x]) <span class="comment">//$x$ 可能是割点</span></span><br><span class="line">                <span class="keyword">if</span> (x != root || cnt &gt;= <span class="number">2</span>) <span class="comment">//排除根 结点只有 $1$个子 结点</span></span><br><span class="line">                    cut[x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//$nxt$ 去过，所以 $nxt$ 还没有回溯，不能用 $low_nxt$</span></span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[nxt]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>割边</p>
<ul>
<li>
<p>在无向图中，若删除 $1$ 条边 $e$ 后，连通块的数量增加，那么称 $e$ 为一条割边。</p>
</li>
<li>
<p>性质：割边一定不在环上，在环上的边一定不是割边。</p>
</li>
<li>
<p>割边涉及的通常是“必经边”的问题。</p>
</li>
<li>
<p>不用证明：割边删除后，恰好增加 $1$ 个连通块。</p>
</li>
<li>
<p>割边的判定</p>
<ul>
<li>
<p>维护 $dfn_x$ 和 $low_x$ 之后，对于 $x$ 到 $y$ 的连边，若 $low_y &gt; dfn_x$，则 <code>bridge[i] = bridge[i^1] = true</code>（对于链式前向星的方法）。</p>
</li>
<li>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dfn[N], low[N], num, ans;</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : nbr[x])<span class="comment">//这里的 $w$ 不是权值，是边的编号</span></span><br><span class="line">		<span class="keyword">if</span> (!dfn[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(nxt, w);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[nxt]);</span><br><span class="line">			<span class="keyword">if</span> (low[nxt] &gt; dfn[x])</span><br><span class="line">				cut[w] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (w != edge)</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[nxt]);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = i;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i])</span><br><span class="line">			<span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		ans += cut[i];</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="例题">例题</h3>
<h4 id="洛谷P3388">洛谷P3388</h4>
<p><a href="https://www.luogu.com.cn/problem/P3388">P3388 【模板】割点（割顶）</a></p>
<p>题意：给出一个 $n$ 个点，$m$ 条边的无向图，求图的割点。</p>
<h4 id="CF22C">CF22C</h4>
<p>题意：构造 $n$ 个点 $m$ 条边的无向连通图，且无重边，点 $v$ 必须是割点。需特判无解。</p>
<ol>
<li>有解时，$m$ 一定有上界和下界，下届为 $m \ge n-1$；</li>
<li>$v$ 已经连接了 $n-1$ 个点，不能有重边，因此 $v$ 不能再连边，视为 $v$ 不存在；</li>
<li>为了保证容纳的边尽可能多，要尽量连完全图，且不能破坏 $v$ 的割点特征；</li>
<li>留 $1$ 个单点只跟 $v$ 保持连边，剩下的 $n-2$ 个点构造完全图即可；</li>
<li>上界 $m \le n-1+ (n-2)\times(n-3)/2$。</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, v;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> print(x, y) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; v;</span><br><span class="line">	<span class="keyword">if</span> (m &lt; n - <span class="number">1</span> || m &gt; n - <span class="number">1</span> + (n - <span class="number">2</span>) * (n - <span class="number">3</span>) / <span class="number">2</span>)</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		m -= n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (v == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">			<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; n; i++)</span><br><span class="line">				<span class="built_in">print</span>(i, i + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">					<span class="keyword">if</span> (m--)</span><br><span class="line">						<span class="built_in">print</span>(i, j);</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						<span class="keyword">goto</span> end;<span class="comment">//不建议使用 `goto`，我是为了方便。</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; i++)</span><br><span class="line">				<span class="keyword">if</span> (m--)</span><br><span class="line">					<span class="built_in">print</span>(i, <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">goto</span> end;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">				<span class="built_in">print</span>(i, i + <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">print</span>(<span class="number">1</span>, v);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">					<span class="keyword">if</span> (m--)</span><br><span class="line">						<span class="built_in">print</span>(i, j);</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						<span class="keyword">goto</span> end;</span><br><span class="line">		&#125;</span><br><span class="line">	end:;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="洛谷P3469">洛谷P3469</h4>
<p><a href="https://www.luogu.com.cn/problem/P3469">P3469 BLO-Blockade</a></p>
<p>题意：对于每个结点 $i$ 求出，把与结点 $i$ 关联的所有边去掉以后（不去掉结点 $i$ 本身），无向图有多少个有序点 $(x,y)$，满足 $x$ 和 $y$ 不连通。</p>
<ul>
<li>一个点 $x$，如果是不是割点，那么贡献一定是 $(n-2) \div 2$；否则贡献是 $(n-1)+(z+1)(n-z-1)+\sum_{y = A_i}{y(n-y)}$。其中 $A_i$ 为 结点 $i$ 满足：$i$ 是 $x$ 的子 结点，$i$ 之前没有访问过且 $low_i \ge dfn_x$；$z$ 为 $\sum a_i$。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dfn[N], low[N], num, root, ans[N], sum[N];</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num;</span><br><span class="line">	sum[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (!dfn[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(nxt);</span><br><span class="line">			sum[x] += sum[nxt];</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[nxt]);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span> (low[nxt] &gt;= dfn[x])</span><br><span class="line">			&#123;</span><br><span class="line">				ans[x] += sum[nxt] * (n - sum[nxt]);</span><br><span class="line">				tot += sum[nxt];</span><br><span class="line">				<span class="keyword">if</span> (x != root || cnt &gt;= <span class="number">2</span>)</span><br><span class="line">					cut[x] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[nxt]);</span><br><span class="line">	<span class="keyword">if</span> (!cut[x])</span><br><span class="line">		ans[x] = <span class="number">2</span> * (n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ans[x] += (n - tot - <span class="number">1</span>) * (tot + <span class="number">1</span>) + (n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = <span class="number">1</span>;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i])</span><br><span class="line">			root = i, <span class="built_in">tarjan</span>(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="洛谷P1656">洛谷P1656</h4>
<p><a href="https://www.luogu.com.cn/problem/P1656">P1656 炸铁路</a></p>
<p>题意：求割边，模板题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dfn[N], low[N], num, ans, cnt;</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;a[N], b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (!dfn[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(nxt, w);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[nxt]);</span><br><span class="line">			<span class="keyword">if</span> (low[nxt] &gt; dfn[x])</span><br><span class="line">				cut[w] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (w != edge)</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[nxt]);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = i;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">		a[i] = &#123; <span class="built_in">min</span>(x,y),<span class="built_in">max</span>(x,y) &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i])</span><br><span class="line">			<span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="keyword">if</span> (cut[i])</span><br><span class="line">			b[++cnt] = a[i];</span><br><span class="line">	<span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + cnt);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">		cout &lt;&lt; b[i].first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[i].second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="洛谷P7687">洛谷P7687</h4>
<p><a href="https://www.luogu.com.cn/problem/P7687">P1656</a></p>
<ol>
<li>初始时，所有点都能访问 A 和 B 类服务；</li>
<li>如果一条边，非割边，意味着在环上，删除后不改变连通性，不可能是关键边；</li>
<li>关键边应该是割边的一个子集；</li>
<li>对于 $x$ 到 $y$ 的连边，两侧不能出现没有 A 或者没有 B 类服务的点；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dfn[N], low[N], num, ans, a[N], b[N], k, l;</span><br><span class="line"><span class="type">bool</span> cut[N], vis[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;c[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (!dfn[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(nxt, w);</span><br><span class="line">			a[x] += a[nxt];</span><br><span class="line">			b[x] += b[nxt];</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[nxt]);</span><br><span class="line">			<span class="keyword">if</span> (low[nxt] &gt; dfn[x])</span><br><span class="line">			&#123;</span><br><span class="line">				cut[w] = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">max</span>(a[nxt], k - a[nxt]) == k || <span class="built_in">max</span>(b[nxt], l - b[nxt]) == l)</span><br><span class="line">					vis[w] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (w != edge)</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[nxt]);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; l;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		a[x] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		b[x] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = i;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">		c[i] = &#123; x,y &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i])</span><br><span class="line">			<span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		ans += vis[i];</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="keyword">if</span> (vis[i])</span><br><span class="line">			cout &lt;&lt; c[i].first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[i].second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="边双连通分量">边双连通分量</h2>
<ul>
<li>边双连通：若无向图中点 $x$ 和 $y$ 在删除任意连边后，仍然连通，称 $x$ 和 $y$ 是边双连通的；</li>
<li>边双连通分量：若无向图 $G$ 中，存在一个极大子图 $G’$，$G’$ 中没有割边，那么 $G’$ 是 $G$ 的一个边双连通分量记为 E-DCC；</li>
</ul>
<h3 id="例题-2">例题</h3>
<h4 id="洛谷T103489">洛谷T103489</h4>
<p><a href="https://www.luogu.com.cn/problem/T103489">T103489 【模板】边双连通分量</a></p>
<p>题意：给定一个 $n$ 个点 $m$ 条边的无向图，求边双连通分量（e-dcc）数量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dfn[N], low[N], num, ans, cnt, dcc[N], id;</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (!dfn[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(nxt, w);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[nxt]);</span><br><span class="line">			<span class="keyword">if</span> (low[nxt] &gt; dfn[x])</span><br><span class="line">				cut[w] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (w != edge)</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[nxt]);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dcc[x] = id;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (!dcc[nxt] &amp;&amp; !cut[w])</span><br><span class="line">			<span class="built_in">dfs</span>(nxt);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = i;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">		a[i] = &#123; <span class="built_in">min</span>(x,y),<span class="built_in">max</span>(x,y) &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i])</span><br><span class="line">			<span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dcc[i])</span><br><span class="line">			id++, <span class="built_in">dfs</span>(i);</span><br><span class="line">	cout &lt;&lt; id;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CF51F">CF51F</h4>
<ol>
<li>图可能不连通，视为多个毛毛虫的拼接，每两个操作 $1$ 次；</li>
<li>对于一张连通图， 缩边双连通分量变为一棵树；</li>
<li>对于一棵树，操作叶子结点不会比操作叶子的父结点更优，所以叶子结点保留；</li>
<li>保留的主链越长越好，取树的直径最优，设长度为 $len$，且子结点为 $cnt$ 个，$n-len-cnt+2$；</li>
<li>设一个边双的结点数为 $size$，一个边双需要操作 $size-1$ 次；</li>
</ol>
<h2 id="点双连通分量">点双连通分量</h2>
<ul>
<li>
<p>点双连通：无向图中，若点 $x$ 和 $y$，在删除任一点 $z$（$z\not=x, z\not=y$）后，$x$ 和 $y$ 仍然连通，那么称点 $x$ 和 $y$ 是点双连通的。</p>
</li>
<li>
<p>点双连通分量：无向图 $G$ 中，若存在极大子图 $G’$，$G’$ 中没有割点，那么 $G’$ 称之为 $G$ 的一个点双连通分量，记为 V-DCC。</p>
</li>
</ul>
<p>推论：</p>
<ul>
<li>
<p>边双连通分量由割边连接，所以一个点只能在 $1$ 个 E-DCC 里；</p>
</li>
<li>
<p>点双连通分量由割点链接，而 $1$ 个点可以链接多条边，因此 $1$ 个点可以在多个 V-DCC 里；</p>
</li>
<li>
<p>若 $1$ 个点在超过 $1$ 个 V-DCC 中，则该点一定是割点；</p>
</li>
<li>
<p>当研究一个 V-DCC 时，其内部没有“割点”，当研究整个图时，多个 V-DCC 的交点就是割点；</p>
</li>
<li>
<p>一条边只能在一个 V-DCC 中。</p>
</li>
</ul>
<h3 id="例题-3">例题</h3>
<h4 id="洛谷P8435">洛谷P8435</h4>
<p><a href="https://www.luogu.com.cn/problem/P8435">P8435 【模板】点双连通分量</a></p>
<p>题意：对于一个 $n$ 个节点 $m$ 条无向边的图，请输出其点双连通分量的个数，并且输出每个点双连通分量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, dfn[N], low[N], num, root, cnt;</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;nbr[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;dcc[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++num;</span><br><span class="line">	q.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">if</span> (x == root &amp;&amp; !nbr[x].<span class="built_in">size</span>())<span class="comment">//x是单点</span></span><br><span class="line">	&#123;</span><br><span class="line">		dcc[++cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : nbr[x])</span><br><span class="line">		<span class="keyword">if</span> (!dfn[nxt])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(nxt);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[nxt]);</span><br><span class="line">			<span class="keyword">if</span> (low[nxt] &gt;= dfn[x])</span><br><span class="line">			&#123;</span><br><span class="line">				tot++;</span><br><span class="line">				<span class="keyword">if</span> (x != root || tot &gt;= <span class="number">2</span>)</span><br><span class="line">					cut[x] = <span class="literal">true</span>;</span><br><span class="line">				<span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">				cnt++;</span><br><span class="line">				<span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; tmp != nxt)</span><br><span class="line">				&#123;</span><br><span class="line">					tmp = q.<span class="built_in">top</span>();</span><br><span class="line">					q.<span class="built_in">pop</span>();</span><br><span class="line">					dcc[cnt].<span class="built_in">push_back</span>(tmp);</span><br><span class="line">				&#125;</span><br><span class="line">				dcc[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[nxt]);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, z = <span class="number">1</span>;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (x == y)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		nbr[x].<span class="built_in">push_back</span>(&#123; y,z &#125;);</span><br><span class="line">		nbr[y].<span class="built_in">push_back</span>(&#123; x,z &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i])</span><br><span class="line">			root = i, <span class="built_in">tarjan</span>(i);</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; dcc[i].<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : dcc[i])</span><br><span class="line">			cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
        <category>连通性问题</category>
      </categories>
      <tags>
        <tag>连通性问题</tag>
      </tags>
  </entry>
</search>
